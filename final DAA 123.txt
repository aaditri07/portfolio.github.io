#include <iostream>
#include <vector>
#include <map>
#include <unordered_map>
#include <list>
#include <set>
#include <queue>
#include <string>
#include <algorithm>
#include <limits>
#include <numeric>
#include <unordered_map>
#include <unordered_set>
#include <iomanip> // For setting decimal precision
#include<fstream>

using namespace std;
struct Crop {
    string name;
    int yield;
    unordered_set<string> incompatibleCrops;

    Crop(string name, int yield) : name(name), yield(yield) {}
};

// Global variables for optimal yield and arrangement
int bestYield = 0; // To store the maximum yield found
vector<string> bestArrangement; // To store the best crop arrangement

// Function to check if the current arrangement is valid
bool isValidArrangement(const vector<string>& arrangement, const string& crop, int field, const vector<Crop>& crops) {
    for (int i = 0; i < field; i++) {
        if (arrangement[i].empty()) continue; // Skip empty fields
        if (crops[crop[0] - 'A'].incompatibleCrops.find(arrangement[i]) != crops[crop[0] - 'A'].incompatibleCrops.end()) {
            return false; // Incompatible crop found
        }
    }
    return true;
}

// Backtracking function to find the optimal crop arrangement
void backtrackOptimalCrop(int field, vector<string>& arrangement, int currentYield, int numFields, const vector<Crop>& crops) {
    // If we have assigned crops to all fields, check if this arrangement is better
    if (field == numFields) {
        if (currentYield > bestYield) {
            bestYield = currentYield;
            bestArrangement = arrangement; // Store the best arrangement
        }
        return;
    }

    // Try each crop in the current field
    for (int i = 0; i < crops.size(); i++) {
        string crop = crops[i].name;

        // Check if the arrangement is valid before placing the crop
        if (isValidArrangement(arrangement, crop, field, crops)) {
            arrangement[field] = crop; // Place crop in field
            backtrackOptimalCrop(field + 1, arrangement, currentYield + crops[i].yield, numFields, crops);
            arrangement[field] = ""; // Remove crop (backtrack)
        }
    }
}

// Function to optimize crop arrangement
void optimizeCropArrangement() {
    int numFields, numCrops;

    cout << "Optimize Crop Arrangement\n";
    cout << "This function helps you arrange your crops in an optimal way to maximize yield.\n";

    cout << "Enter the number of fields (including vertical layers): ";
    cin >> numFields;

    cout << "Enter the number of crops: ";
    cin >> numCrops;

    vector<Crop> crops;
    for (int i = 0; i < numCrops; ++i) {
        string cropName;
        int cropYield;

        cout << "Enter crop name: ";
        cin >> cropName;

        cout << "Enter yield for " << cropName << ": ";
        cin >> cropYield;

        Crop crop(cropName, cropYield);

        int numIncompatible;
        cout << "Enter the number of incompatible crops for " << cropName << ": ";
        cin >> numIncompatible;

        cout << "Enter the incompatible crops (space-separated): ";
        for (int j = 0; j < numIncompatible; ++j) {
            string incompatibleCrop;
            cin >> incompatibleCrop;
            crop.incompatibleCrops.insert(incompatibleCrop);
        }

        crops.push_back(crop);
    }

    vector<string> arrangement(numFields, "");
    backtrackOptimalCrop(0, arrangement, 0, numFields, crops);

    cout << "\nBest Crop Arrangement:\n";
    for (int i = 0; i < bestArrangement.size(); ++i) {
        cout << "Field " << i + 1 << ": " << bestArrangement[i] << endl;
    }
    cout << "Total Yield: " << bestYield << endl;
}

// Structure to represent a resource

// Structure to represent a resource
struct Resource_1 {
    string name;
    int allocationTime; // Time to allocate the resource
    vector<string> dependencies; // List of dependent resources

    Resource_1() : name(""), allocationTime(0) {} // Default constructor
    Resource_1(string n, int t) : name(n), allocationTime(t) {}
};

// Function to perform a depth-first search (DFS) to determine the total allocation time
int calculateTotalAllocationTime(const string& resourceName, const map<string, Resource_1>& resources,
    map<string, bool>& visited, map<string, int>& timeCache) {
    // If the resource is already visited, return cached time
    if (visited[resourceName]) {
        return timeCache[resourceName];
    }

    // Mark the resource as visited
    visited[resourceName] = true;

    // Initialize total time with the current resource's allocation time
    int totalTime = resources.at(resourceName).allocationTime;

    // Traverse through dependencies and sum up the times
    for (const string& dep : resources.at(resourceName).dependencies) {
        if (resources.find(dep) != resources.end()) {
            totalTime += calculateTotalAllocationTime(dep, resources, visited, timeCache);
        } else {
            cerr << "Error: Dependency '" << dep << "' not found for resource '" << resourceName << "'." << endl;
            exit(EXIT_FAILURE);
        }
    }

    // Cache the calculated time for the resource
    timeCache[resourceName] = totalTime;
    return totalTime;
}

// Function to determine allocation times
void determineAllocationTimes() {
    int numResources;

    cout << "Enter the number of resources: ";
    cin >> numResources;

    map<string, Resource_1> resources;

    for (int i = 0; i < numResources; ++i) {
        string resourceName;
        int allocationTime;

        cout << "Enter resource name: ";
        cin >> resourceName;

        cout << "Enter allocation time for " << resourceName << ": ";
        cin >> allocationTime;

        Resource_1 resource(resourceName, allocationTime);

        int numDependencies;
        cout << "Enter the number of dependencies for " << resourceName << ": ";
        cin >> numDependencies;

        cout << "Enter the dependent resources (space-separated): ";
        for (int j = 0; j < numDependencies; ++j) {
            string dependency;
            cin >> dependency;
            resource.dependencies.push_back(dependency);
        }

        resources[resourceName] = resource;
    }

    cout << "\nCalculating Total Allocation Times:\n";
    for (const auto& entry : resources) {
        const string& resourceName = entry.first;
        map<string, bool> visited;
        map<string, int> timeCache;

        try {
            int totalTime = calculateTotalAllocationTime(resourceName, resources, visited, timeCache);
            cout << "Total allocation time for " << resourceName << ": " << totalTime << endl;
        } catch (const out_of_range& e) {
            cerr << "Error: " << e.what() << ". Resource '" << resourceName << "' might be missing dependencies." << endl;
        }
    }
}
struct SoilSample {
    string sampleID;
    double pH; // pH level
    double nitrogen; // Nitrogen content
    double phosphorus; // Phosphorus content
    double potassium; // Potassium content

    SoilSample(string id, double pHValue, double nValue, double pValue, double kValue)
        : sampleID(id), pH(pHValue), nitrogen(nValue), phosphorus(pValue), potassium(kValue) {}
};

// Function to calculate and display soil analysis statistics
void analyzeSoilQuality(const vector<SoilSample>& samples) {
    double totalPH = 0, totalNitrogen = 0, totalPhosphorus = 0, totalPotassium = 0;
    int numSamples = samples.size();

    for (const auto& sample : samples) {
        totalPH += sample.pH;
        totalNitrogen += sample.nitrogen;
        totalPhosphorus += sample.phosphorus;
        totalPotassium += sample.potassium;
    }

    // Calculate averages
    double avgPH = totalPH / numSamples;
    double avgNitrogen = totalNitrogen / numSamples;
    double avgPhosphorus = totalPhosphorus / numSamples;
    double avgPotassium = totalPotassium / numSamples;

    // Display results
    cout << "\nSoil Quality Analysis Results:\n";
    cout << fixed << setprecision(2); // Set precision for output
    cout << "Average pH Level: " << avgPH << endl;
    cout << "Average Nitrogen Content: " << avgNitrogen << " mg/kg" << endl;
    cout << "Average Phosphorus Content: " << avgPhosphorus << " mg/kg" << endl;
    cout << "Average Potassium Content: " << avgPotassium << " mg/kg" << endl;
}

// Function to provide recommendations based on soil analysis
void provideSoilRecommendations(const vector<SoilSample>& samples) {
    double totalPH = 0, totalNitrogen = 0, totalPhosphorus = 0, totalPotassium = 0;
    int numSamples = samples.size();

    for (const auto& sample : samples) {
        totalPH += sample.pH;
        totalNitrogen += sample.nitrogen;
        totalPhosphorus += sample.phosphorus;
        totalPotassium += sample.potassium;
    }

    double avgPH = totalPH / numSamples;
    double avgNitrogen = totalNitrogen / numSamples;
    double avgPhosphorus = totalPhosphorus / numSamples;
    double avgPotassium = totalPotassium / numSamples;

    cout << fixed << setprecision(2);
    cout << "Average pH Level: " << avgPH << endl;
    cout << "Average Nitrogen Content: " << avgNitrogen << " mg/kg" << endl;
    cout << "Average Phosphorus Content: " << avgPhosphorus << " mg/kg" << endl;
    cout << "Average Potassium Content: " << avgPotassium << " mg/kg" << endl;

    // Provide actionable insights
    if (avgPH < 6.0) {
        cout << "Recommendation: Soil is too acidic. Consider adding lime to raise pH.\n";
    } else if (avgPH > 7.5) {
        cout << "Recommendation: Soil is too alkaline. Consider adding sulfur to lower pH.\n";
    }

    if (avgNitrogen < 20) {
        cout << "Recommendation: Nitrogen levels are low. Consider adding a nitrogen-rich fertilizer.\n";
    }

    if (avgPhosphorus < 15) {
        cout << "Recommendation: Phosphorus levels are low. Consider adding a phosphorus-rich fertilizer.\n";
    }

    if (avgPotassium < 20) {
        cout << "Recommendation: Potassium levels are low. Consider adding a potassium-rich fertilizer.\n";
    }
}

void analyzeSoilSamples() {
    int numSamples;
    cout << "Enter the number of soil samples: ";
    cin >> numSamples;

    if (numSamples <= 0) {
        cout << "Invalid number of soil samples. Please enter a positive value." << endl;
        return;
    }

    vector<SoilSample> samples;

    for (int i = 1; i <= numSamples; ++i) {
        string id;
        double pH, nitrogen, phosphorus, potassium;

        cout << "\nEntering details for Soil Sample " << i << ":\n";
        cout << "Sample ID: ";
        cin >> id;
        cout << "pH Level: ";
        cin >> pH;
        cout << "Nitrogen Content (mg/kg): ";
        cin >> nitrogen;
        cout << "Phosphorus Content (mg/kg): ";
        cin >> phosphorus;
        cout << "Potassium Content (mg/kg): ";
        cin >> potassium;

        samples.emplace_back(id, pH, nitrogen, phosphorus, potassium);
    }

    analyzeSoilQuality(samples);
    provideSoilRecommendations(samples);
}
// Structure to hold crop properties for crop rotation suggestion
struct RotationCrop {
    string cropName; // Add this line
    int nutrientBenefit; // Nutrient benefit to the soil
    int pestResistance; // Pest resistance level
    int yearsBetween; // Optimal years before replanting

    RotationCrop(string n, int nb, int pr, int yb) : cropName(n), nutrientBenefit(nb), pestResistance(pr), yearsBetween(yb) {}
};

// Function to suggest crop rotation plans based on user input
void suggestCropRotationPlan(const vector<RotationCrop>& crops, int numYears) {
    vector<string> rotationPlan;

    // Start with the first crop and alternate
    for (int year = 0; year < numYears; ++year) {
        // Select a crop based on year
        int cropIndex = year % crops.size();
        rotationPlan.push_back(crops[cropIndex].cropName);
    }

    // Display the suggested crop rotation plan
    cout << "\nSuggested Crop Rotation Plan for " << numYears << " years:\n";
    for (int year = 0; year < rotationPlan.size(); ++year) {
        cout << "Year " << year + 1 << ": " << rotationPlan[year] << endl;
    }

    // Additional suggestion based on nutrient benefits
    cout << "\nNutrient Benefits Summary:\n";
    for (const auto& crop : crops) {
        cout << crop.cropName << ": Nutrient Benefit = " << crop.nutrientBenefit << ", Pest Resistance = " << crop.pestResistance << endl;
    }
}
void suggestCropRotation() {
    int numCrops, numYears;

    cout << "Enter the number of crops: ";
    cin >> numCrops;

    if (numCrops <= 0) {
        cout << "Invalid number of crops. Please enter a positive value." << endl;
        return;
    }

    vector<RotationCrop> crops;

    for (int i = 1; i <= numCrops; ++i) {
        string name;
        int nutrientBenefit, pestResistance, yearsBetween;

        cout << "\nEntering details for Crop " << i << ":\n";
        cout << "Crop Name: ";
        cin >> name;

        cout << "Nutrient Benefit to Soil (1-10 scale): ";
        cin >> nutrientBenefit;

        cout << "Pest Resistance Level (1-10 scale): ";
        cin >> pestResistance;

        cout << "Optimal Years Before Replanting: ";
        cin >> yearsBetween;

        crops.emplace_back(name, nutrientBenefit, pestResistance, yearsBetween);
    }

    cout << "\nEnter the number of years for the crop rotation plan: ";
    cin >> numYears;

    if (numYears <= 0) {
        cout << "Invalid number of years. Please enter a positive value." << endl;
        return;
    }

    suggestCropRotationPlan(crops, numYears);

    // Output suggestions and benefits
    cout << "\nSuggested Crop Rotation Plan for " << numYears << " years:\n";
    for (int year = 0; year < numYears; ++year) {
        // Select a crop based on year
        int cropIndex = year % crops.size();
        cout << "Year " << year + 1 << ": " << crops[cropIndex].cropName << endl;
    }

    cout << "\nNutrient Benefits Summary:\n";
    for (const auto& crop : crops) {
        cout << crop.cropName << ": Nutrient Benefit = " << crop.nutrientBenefit << ", Pest Resistance = " << crop.pestResistance << endl;
    }
}
// Structure to hold crop properties for yield estimation
struct YieldCrop {
    string name;
    double baseYield; // Base yield per hectare
    double climateFactor; // Factor based on climate conditions
    double soilFactor; // Factor based on soil quality
    double pestFactor; // Factor based on pest resistance

    YieldCrop(string n, double by, double cf, double sf, double pf)
        : name(n), baseYield(by), climateFactor(cf), soilFactor(sf), pestFactor(pf) {}
};

// Function to estimate crop yield based on growth conditions
double estimateCropYield(const YieldCrop& crop) {
    return crop.baseYield * crop.climateFactor * crop.soilFactor * crop.pestFactor;
}

// Function to gather crop data from user input
void gatherCropData(vector<YieldCrop>& crops, int numCrops) {
    for (int i = 1; i <= numCrops; ++i) {
        string name;
        double baseYield, climateFactor, soilFactor, pestFactor;

        cout << "\nEntering details for Crop " << i << ":\n";
        cout << "Crop Name: ";
        cin >> name;

        cout << "Base Yield per Hectare (kg): ";
        cin >> baseYield;

        cout << "Climate Factor (0.0 - 1.0): ";
        cin >> climateFactor;

        cout << "Soil Quality Factor (0.0 - 1.0): ";
        cin >> soilFactor;

        cout << "Pest Resistance Factor (0.0 - 1.0): ";
        cin >> pestFactor;

        // Create a Crop object and add it to the vector
        crops.emplace_back(name, baseYield, climateFactor, soilFactor, pestFactor);
    }
}

void estimateCropYields() {
    int numCrops;

    cout << "Enter the number of crops: ";
    cin >> numCrops;

    if (numCrops <= 0) {
        cout << "Invalid number of crops. Please enter a positive value." << endl;
        return;
    }

    vector<YieldCrop> crops;

    gatherCropData(crops, numCrops);

    cout << "\nEstimated Crop Yields:\n";
    cout << fixed << setprecision(2);
    for (const auto& crop : crops) {
        double estimatedYield = estimateCropYield(crop);
        cout << "Crop: " << crop.name << ", Estimated Yield: " << estimatedYield << " kg/ha" << endl;
    }

    // Provide guidance on yield improvement
    cout << "\nYield Improvement Tips:\n";
    for (const auto& crop : crops) {
        if (crop.climateFactor < 0.8) {
            cout << "Crop: " << crop.name << " - Consider optimizing microclimate conditions (e.g., temperature, humidity).\n";
        }
        if (crop.soilFactor < 0.8) {
            cout << "Crop: " << crop.name << " - Improve soil quality using organic amendments or fertilizers.\n";
        }
        if (crop.pestFactor < 0.8) {
            cout << "Crop: " << crop.name << " - Implement integrated pest management strategies.\n";
        }
    }
}

// Structure to hold farming tool properties and electricity requirements
struct FarmingTool {
    string name;
    double powerRequired; // Power needed (kWh)
    double operationalHours; // Number of hours the tool is used
    double costPerKWh; // Cost of electricity per kWh

    FarmingTool(string n, double pr, double oh, double c)
        : name(n), powerRequired(pr), operationalHours(oh), costPerKWh(c) {}
};

// Function to display farming tool details
void displayToolDetails(const vector<FarmingTool>& tools) {
    cout << "\nCurrent Farming Tool Details:\n";
    cout << left << setw(20) << "Tool Name"
         << setw(15) << "Power Req (kWh)"
         << setw(20) << "Operational Hours"
         << setw(15) << "Cost per kWh"
         << endl;
    cout << string(75, '-') << endl;

    for (const auto& tool : tools) {
        cout << left << setw(20) << tool.name
             << setw(15) << tool.powerRequired
             << setw(20) << tool.operationalHours
             << setw(15) << tool.costPerKWh
             << endl;
    }
}

// Function to allocate electricity efficiently among farming tools
void allocateElectricityForFarms(const vector<FarmingTool>& tools, double totalElectricityAvailable) {
    cout << "\nAllocating Electricity for Farming Tools:\n";

    // Total power requirement calculation
    double totalPowerRequired = 0;
    for (const auto& tool : tools) {
        totalPowerRequired += tool.powerRequired * tool.operationalHours; // Total power needed for each tool
    }

    cout << fixed << setprecision(2); // Set decimal precision for output

    if (totalPowerRequired == 0) {
        cout << "No tools require electricity.\n";
        return;
    }

    // Electricity distribution based on available resources
    cout << "\nAllocated Electricity Distribution:\n";
    cout << left << setw(20) << "Tool Name" << setw(25) << "Allocated Power (kWh)" << setw(20) << "Total Cost ($)" << endl;
    cout << string(70, '-') << endl;

    for (const auto& tool : tools) {
        double allocatedPower = (totalElectricityAvailable / totalPowerRequired) * (tool.powerRequired * tool.operationalHours);
        double totalCost = allocatedPower * tool.costPerKWh;

        cout << left << setw(20) << tool.name
             << setw(25) << allocatedPower
             << setw(20) << totalCost
             << endl;
    }
}
void manageFarmingTools() {
    int numTools;

    cout << "Enter the number of farming tools: ";
    cin >> numTools;

    if (numTools <= 0) {
        cout << "Invalid number of farming tools. Please enter a positive value." << endl;
        return;
    }

    vector<FarmingTool> tools;

    for (int i = 1; i <= numTools; ++i) {
        string name;
        double powerReq, operationalHours, costPerKWh;

        cout << "\nEntering details for Farming Tool " << i << ":\n";
        cout << "Tool Name: ";
        cin >> name;

        cout << "Power Required (kWh): ";
        cin >> powerReq;

        cout << "Operational Hours: ";
        cin >> operationalHours;

        cout << "Cost of Electricity per kWh: ";
        cin >> costPerKWh;

        tools.emplace_back(name, powerReq, operationalHours, costPerKWh);
    }

    double totalElectricityAvailable;
    cout << "\nEnter total electricity available for allocation (kWh): ";
    cin >> totalElectricityAvailable;

    displayToolDetails(tools);
    allocateElectricityForFarms(tools, totalElectricityAvailable);

    // Provide actionable insights
    cout << "\nRecommendations for Energy Efficiency:\n";
    for (const auto& tool : tools) {
        if (tool.powerRequired > 10) {
            cout << "Tool: " << tool.name << " - Consider using energy-efficient alternatives or optimizing usage.\n";
        }
    }
}
// Structure to hold crop properties and nutrient requirements
struct CropNutrient {
    string name;
    double nitrogenRequired; // Required nitrogen (kg)
    double phosphorusRequired; // Required phosphorus (kg)
    double potassiumRequired; // Required potassium (kg)
    double area; // Area planted with this crop (hectares)

    CropNutrient(string n, double nReq, double pReq, double kReq, double a)
        : name(n), nitrogenRequired(nReq), phosphorusRequired(pReq), potassiumRequired(kReq), area(a) {}
};

// Function to display crop details
void displayCropDetails(const vector<CropNutrient>& crops) {
    cout << "\nCurrent Crop Nutrient Requirements:\n";
    cout << left << setw(20) << "Crop Name"
         << setw(15) << "N (kg)"
         << setw(15) << "P (kg)"
         << setw(15) << "K (kg)"
         << setw(15) << "Area (ha)"
         << endl;
    cout << string(80, '-') << endl;

    for (const auto& crop : crops) {
        cout << left << setw(20) << crop.name
             << setw(15) << crop.nitrogenRequired
             << setw(15) << crop.phosphorusRequired
             << setw(15) << crop.potassiumRequired
             << setw(15) << crop.area
             << endl;
    }
}

// Function to calculate and manage fertilizer usage
void manageFertilizerUsage(const vector<CropNutrient>& crops, double totalNitrogen, double totalPhosphorus, double totalPotassium) {
    cout << "\nManaging Fertilizer Usage:\n";

    // Total nutrient requirements calculation
    double totalNNeeded = 0, totalPNeeded = 0, totalKNeeded = 0;
    for (const auto& crop : crops) {
        totalNNeeded += crop.nitrogenRequired * crop.area; // Total nitrogen needed
        totalPNeeded += crop.phosphorusRequired * crop.area; // Total phosphorus needed
        totalKNeeded += crop.potassiumRequired * crop.area; // Total potassium needed
    }

    cout << fixed << setprecision(2); // Set decimal precision for output
    cout << "\nTotal Nutrient Requirements:\n";
    cout << "Nitrogen Needed: " << totalNNeeded << " kg\n";
    cout << "Phosphorus Needed: " << totalPNeeded << " kg\n";
    cout << "Potassium Needed: " << totalKNeeded << " kg\n";

    // Calculate fertilizer allocations
    cout << "\nFertilizer Allocations:\n";
    cout << left << setw(20) << "Nutrient" << setw(15) << "Available (kg)" << setw(15) << "Allocated (kg)" << endl;
    cout << string(65, '-') << endl;

    // Allocation logic
    double allocatedN = min(totalNitrogen, totalNNeeded);
    double allocatedP = min(totalPhosphorus, totalPNeeded);
    double allocatedK = min(totalPotassium, totalKNeeded);

    cout << left << setw(20) << "Nitrogen" << setw(15) << totalNitrogen << setw(15) << allocatedN << endl;
    cout << left << setw(20) << "Phosphorus" << setw(15) << totalPhosphorus << setw(15) << allocatedP << endl;
    cout << left << setw(20) << "Potassium" << setw(15) << totalPotassium << setw(15) << allocatedK << endl;
}
void manageCropNutrients() {
    int numCrops;

    cout << "Enter the number of crops: ";
    cin >> numCrops;

    if (numCrops <= 0) {
        cout << "Invalid number of crops. Please enter a positive value." << endl;
        return;
    }

    vector<CropNutrient> crops;

    for (int i = 1; i <= numCrops; ++i) {
        string name;
        double nReq, pReq, kReq, area;

        cout << "\nEntering details for Crop " << i << ":\n";
        cout << "Crop Name: ";
        cin >> name;

        cout << "Nitrogen Required (kg/ha): ";
        cin >> nReq;

        cout << "Phosphorus Required (kg/ha): ";
        cin >> pReq;

        cout << "Potassium Required (kg/ha): ";
        cin >> kReq;

        cout << "Area planted with this crop (hectares): ";
        cin >> area;

        crops.emplace_back(name, nReq, pReq, kReq, area);
    }

    double totalNitrogen, totalPhosphorus, totalPotassium;
    cout << "\nEnter total available nitrogen (kg): ";
    cin >> totalNitrogen;
    cout << "Enter total available phosphorus (kg): ";
    cin >> totalPhosphorus;
    cout << "Enter total available potassium (kg): ";
    cin >> totalPotassium;

    displayCropDetails(crops);
    manageFertilizerUsage(crops, totalNitrogen, totalPhosphorus, totalPotassium);

    // Provide actionable insights
    cout << "\nRecommendations for Nutrient Management:\n";
    for (const auto& crop : crops) {
        if (crop.nitrogenRequired > 100) {
            cout << "Crop: " << crop.name << " - Consider using slow-release nitrogen fertilizers.\n";
        }
        if (crop.phosphorusRequired > 50) {
            cout << "Crop: " << crop.name << " - Consider using phosphorus-efficient crop varieties.\n";
        }
    }
}
struct Resource {
    string name;
    double totalAvailable; // Total amount available for sharing
    double sharedAmount; // Amount shared

    Resource(string n, double ta) : name(n), totalAvailable(ta), sharedAmount(0) {}
};

// Function to display resource details
void displayResourceDetails(const vector<Resource>& resources) {
    cout << "\nCurrent Resource Details:\n";
    cout << left << setw(20) << "Resource Name"
         << setw(20) << "Total Available"
         << setw(20) << "Shared Amount"
         << endl;
    cout << string(60, '-') << endl;

    for (const auto& resource : resources) {
        cout << left << setw(20) << resource.name
             << setw(20) << resource.totalAvailable
             << setw(20) << resource.sharedAmount
             << endl;
    }
}

// Function to facilitate resource sharing between farms
void shareResourcesBetweenFarms(vector<Resource>& resources) {
    cout << "\nFacilitating Resource Sharing:\n";

    for (auto& resource : resources) {
        double shareAmount;
        cout << "Enter amount to share for " << resource.name
             << " (available: " << resource.totalAvailable << "): ";
        while (!(cin >> shareAmount) || shareAmount < 0) {
            cin.clear(); // Clear the error flag
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
            cout << "Invalid amount. Please enter a non-negative value for " << resource.name
                 << " (available: " << resource.totalAvailable << "): ";
        }

        if (shareAmount > resource.totalAvailable) {
            cout << "Cannot share more than available. Sharing the maximum available: "
                 << resource.totalAvailable << endl;
            shareAmount = resource.totalAvailable;
        }

        resource.sharedAmount += shareAmount;
        resource.totalAvailable -= shareAmount;

        cout << "Shared " << shareAmount << " units of " << resource.name << ".\n";
    }
}

void manageResourceSharing() {
    int numResources;

    cout << "Enter the number of resources: ";
    while (!(cin >> numResources) || numResources <= 0) {
        cin.clear(); // Clear the error flag
        cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
        cout << "Invalid number of resources. Please enter a positive value: ";
    }

    vector<Resource> resources;

    for (int i = 1; i <= numResources; ++i) {
        string name;
        double totalAvailable;

        cout << "\nEntering details for Resource " << i << ":\n";
        cout << "Resource Name: ";
        cin >> name;

        cout << "Total Available: ";
        while (!(cin >> totalAvailable) || totalAvailable < 0) {
            cin.clear(); // Clear the error flag
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
            cout << "Invalid amount. Please enter a non-negative value for Total Available: ";
        }

        resources.emplace_back(name, totalAvailable);
    }

    displayResourceDetails(resources);
    shareResourcesBetweenFarms(resources);
    displayResourceDetails(resources);

    // Provide actionable insights
    cout << "\nRecommendations for Resource Sharing:\n";
    for (const auto& resource : resources) {
        if (resource.totalAvailable > 1000) {
            cout << "Resource: " << resource.name << " - Consider setting up a community resource pool.\n";
        }
    }
}
// Class to manage farm resource dependencies using a graph structure
class FarmGraph {
private:
    unordered_map<string, list<pair<string, double>>> adjacencyList;

public:
    void addFarm(const string& farmName) {
        adjacencyList[farmName]; // Create an empty list for the farm
    }

    void addResourceDependency(const string& farmA, const string& farmB, double quantity) {
        adjacencyList[farmA].emplace_back(farmB, quantity);
        adjacencyList[farmB].emplace_back(farmA, quantity); // For undirected graph
    }

    void displayGraph() {
        cout << "\nFarm Dependency Graph:\n";
        for (const auto& farm : adjacencyList) {
            cout << farm.first << " => ";
            for (const auto& neighbor : farm.second) {
                cout << "[" << neighbor.first << " | Quantity: " << neighbor.second << "] ";
            }
            cout << endl;
        }
    }

    vector<string> getFarms() const {
        vector<string> farms;
        for (const auto& pair : adjacencyList) {
            farms.push_back(pair.first);
        }
        return farms;
    }

    list<pair<string, double>> getDependencies(const string& farm) const {
        return adjacencyList.at(farm);
    }
};
void manageFarmGraph() {
    FarmGraph graph;
    int numFarms;

    cout << "Enter the number of farms: ";
    cin >> numFarms;

    for (int i = 0; i < numFarms; i++) {
        string farmName;
        cout << "Enter farm name: ";
        cin >> farmName;
        graph.addFarm(farmName);
    }

    int numDependencies;
    cout << "Enter the number of resource dependencies: ";
    cin >> numDependencies;

    for (int i = 0; i < numDependencies; i++) {
        string farmA, farmB;
        double quantity;
        cout << "Enter farm A, farm B and shared resource quantity: ";
        cin >> farmA >> farmB >> quantity;
        graph.addResourceDependency(farmA, farmB, quantity);
    }

    graph.displayGraph();

    // Provide actionable insights
    cout << "\nRecommendations for Farm Network Optimization:\n";
    for (const auto& farm : graph.getFarms()) {
        if (graph.getDependencies(farm).size() > 3) {
            cout << "Farm: " << farm << " - Consider diversifying resource dependencies to reduce risk.\n";
        }
    }
}
// Dijkstra's Algorithm Implementation
class WaterSupplyGraph {
private:
    unordered_map<string, vector<pair<string, double>>> adj;

public:
    void addEdge(const string& u, const string& v, double weight) {
        adj[u].emplace_back(v, weight);
        adj[v].emplace_back(u, weight); // For undirected graph
    }

    void dijkstra(const string& source) {
        unordered_map<string, double> distances;
        unordered_map<string, string> previous;
        set<pair<double, string>> nodes;

        for (const auto& pair : adj) {
            distances[pair.first] = numeric_limits<double>::infinity(); // Initialize distances
            previous[pair.first] = "";
        }
        distances[source] = 0;
        nodes.insert({0, source});

        while (!nodes.empty()) {
            string current = nodes.begin()->second;
            nodes.erase(nodes.begin());

            for (const auto& neighbor : adj[current]) {
                string nextFarm = neighbor.first;
                double weight = neighbor.second;

                double newDist = distances[current] + weight;
                if (newDist < distances[nextFarm]) {
                    nodes.erase({distances[nextFarm], nextFarm});
                    distances[nextFarm] = newDist;
                    previous[nextFarm] = current;
                    nodes.insert({newDist, nextFarm});
                }
            }
        }

        // Display shortest paths
        cout << "\nShortest Paths from " << source << ":\n";
        for (const auto& pair : distances) {
            cout << "To " << pair.first << ": " << pair.second << " units\n";
        }
    }

    vector<pair<string, double>> getEdges() const {
        vector<pair<string, double>> edges;
        for (const auto& pair : adj) {
            for (const auto& neighbor : pair.second) {
                edges.push_back({pair.first, neighbor.second});
            }
        }
        return edges;
    }
};

void manageWaterSupplyGraph() {
    WaterSupplyGraph graph;
    string farmA, farmB;
    double distance;

    // Add farms and distances (edges) to the graph
    while (true) {
        cout << "Enter the names of two farms (or 'done' to finish): ";
        cin >> farmA;
        if (farmA == "done") break;
        cin >> farmB;
        cout << "Enter the distance between " << farmA << " and " << farmB << ": ";
        cin >> distance;
        graph.addEdge(farmA, farmB, distance);
    }

    // Display edges with weight greater than 20
    cout << "\nEdges with distance greater than 20 units:\n";
    for (const auto& edge : graph.getEdges()) {
        if (edge.second > 20) { // Use edge.second to access the weight
            cout << edge.first << " - " << edge.second << " units\n";
        }
    }

    // Run Dijkstra's algorithm from a specified source
    string source;
    cout << "\nEnter the source farm for Dijkstra's algorithm: ";
    cin >> source;
    graph.dijkstra(source);
}
struct Edge {
    string u, v;
    double weight;
    Edge(string u, string v, double weight) : u(u), v(v), weight(weight) {}
};

// Class to represent the resource network and build the MST
class ResourceTree {
public:
    void addEdge(const string& u, const string& v, double weight) {
        edges.emplace_back(u, v, weight);
    }

    void buildMST() {
        // Sort edges based on weight
        sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {
            return a.weight < b.weight;
        });

        // Initialize parent map for union-find
        for (const auto& edge : edges) {
            parent[edge.u] = edge.u;
            parent[edge.v] = edge.v;
        }

        // Kruskal's algorithm to build MST
        for (const auto& edge : edges) {
            if (find(edge.u) != find(edge.v)) {
                mstEdges.push_back(edge);
                unite(edge.u, edge.v);
            }
        }

        // Debug: Print MST edges
        cout << "\nDebug: MST Edges\n";
        for (const auto& edge : mstEdges) {
            cout << edge.u << " - " << edge.v << " (" << edge.weight << ")\n";
        }
    }

    const vector<Edge>& getEdges() const {
        return mstEdges;
    }

private:
    vector<Edge> edges;
    vector<Edge> mstEdges;
    unordered_map<string, string> parent;

    string find(const string& node) {
        if (parent[node] != node) {
            parent[node] = find(parent[node]);
        }
        return parent[node];
    }

    void unite(const string& node1, const string& node2) {
        string root1 = find(node1);
        string root2 = find(node2);
        if (root1 != root2) {
            parent[root2] = root1;
        }
    }
};

// Function to manage the resource network
void manageResourceNetwork() {
    ResourceTree mst;
    int numEdges;

    cout << "Enter the number of edges in the resource network: ";
    cin >> numEdges;

    for (int i = 0; i < numEdges; i++) {
        string farmA, farmB;
        double weight;
        cout << "Enter farm A, farm B and resource weight: ";
        cin >> farmA >> farmB >> weight;
        mst.addEdge(farmA, farmB, weight);
    }

    mst.buildMST();

    // Display the MST
    cout << "\nMinimum Spanning Resource Tree:\n";
    for (const auto& edge : mst.getEdges()) {
        cout << edge.u << " - " << edge.v << " (" << edge.weight << ")\n";
    }

    // Provide actionable insights
    cout << "\nRecommendations for Resource Network Optimization:\n";
    for (const auto& edge : mst.getEdges()) {
        if (edge.weight > 20) {
            cout << "From: " << edge.u << " to: " << edge.v << " - Consider optimizing resource transportation to reduce costs.\n";
        }
    }
}
class MaxFlow {
private:
    int V; // Number of vertices
    vector<vector<int>> capacity; // Capacity matrix
    vector<vector<int>> adj; // Adjacency list

public:
    MaxFlow(int vertices) : V(vertices) {
        capacity.resize(V, vector<int>(V, 0));
        adj.resize(V);
    }

    void addEdge(int u, int v, int cap) {
        capacity[u][v] += cap; // Make sure to allow for multiple edges
        adj[u].push_back(v);
        adj[v].push_back(u); // Add reverse edge for backtracking
    }

    bool bfs(int source, int sink, vector<int>& parent) {
        vector<bool> visited(V, false);
        queue<int> q;

        q.push(source);
        visited[source] = true;

        while (!q.empty()) {
            int u = q.front();
            q.pop();

            for (int v : adj[u]) {
                if (!visited[v] && capacity[u][v] > 0) {
                    q.push(v);
                    visited[v] = true;
                    parent[v] = u; // Store path information

                    if (v == sink) {
                        return true; // If we reached the sink
                    }
                }
            }
        }
        return false; // No path found
    }

    int edmondsKarp(int source, int sink) {
        vector<int> parent(V);
        int maxFlow = 0;

        while (bfs(source, sink, parent)) {
            int pathFlow = numeric_limits<int>::max();

            // Find the maximum flow through the path found by BFS
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                pathFlow = min(pathFlow, capacity[u][v]);
            }

            // Update capacities of the edges and reverse edges along the path
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                capacity[u][v] -= pathFlow;
                capacity[v][u] += pathFlow;
            }

            maxFlow += pathFlow; // Add path flow to overall flow
        }

        return maxFlow;
    }
};
// Structure to represent a connection in the irrigation system
struct IrrigationConnection {
    string start;
    string end;
    int length;
    int capacity;

    IrrigationConnection(string s, string e, int l, int c) : start(s), end(e), length(l), capacity(c) {}
};

// Function to display the irrigation system network
void displayIrrigationSystem(const vector<IrrigationConnection>& connections) {
    cout << "\nIrrigation System Network:\n";
    for (const auto& connection : connections) {
        cout << connection.start << " -> " << connection.end
             << " (" << connection.length << " meters, capacity: " << connection.capacity << ")\n";
    }
}

void manageIrrigationSystem() {
    int numVertices, numEdges;

    cout << "Manage Irrigation System\n";
    cout << "This function optimizes the irrigation system for maximum efficiency.\n";

    cout << "Enter the number of vertices in the irrigation system: ";
    while (!(cin >> numVertices) || numVertices <= 0) {
        cin.clear(); // Clear the error flag
        cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
        cout << "Invalid number of vertices. Please enter a positive value: ";
    }

    cout << "Enter the number of edges: ";
    while (!(cin >> numEdges) || numEdges <= 0) {
        cin.clear(); // Clear the error flag
        cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
        cout << "Invalid number of edges. Please enter a positive value: ";
    }

    vector<IrrigationConnection> connections;

    for (int i = 1; i <= numEdges; ++i) {
        string start, end;
        int length, capacity;

        cout << "\nEntering details for Edge " << i << ":\n";
        cout << "Enter start section: ";
        cin >> start;
        cout << "Enter end section: ";
        cin >> end;

        cout << "Enter pipe length (in meters): ";
        while (!(cin >> length) || length <= 0) {
            cin.clear(); // Clear the error flag
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
            cout << "Invalid length. Please enter a positive value for length: ";
        }

        cout << "Enter capacity: ";
        while (!(cin >> capacity) || capacity <= 0) {
            cin.clear(); // Clear the error flag
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
            cout << "Invalid capacity. Please enter a positive value for capacity: ";
        }

        connections.emplace_back(start, end, length, capacity);
    }

    displayIrrigationSystem(connections);
}
struct CropDependency {
    string primaryCrop;
    string dependentCrop;
    string dependencyType;

    CropDependency(string p, string d, string t) : primaryCrop(p), dependentCrop(d), dependencyType(t) {}
};

// Function to display the crop dependencies
void displayCropDependencies(const vector<CropDependency>& dependencies) {
    cout << "\nCrop Dependencies:\n";
    for (const auto& dependency : dependencies) {
        cout << dependency.primaryCrop << " <-> " << dependency.dependentCrop
             << " (" << dependency.dependencyType << ")\n";
    }
}

// Function to check for conflicts in dependencies
bool checkForConflicts(const vector<CropDependency>& dependencies) {
    unordered_map<string, unordered_set<string>> togetherMap;
    unordered_map<string, unordered_set<string>> avoidMap;
    bool conflict = false;

    for (const auto& dependency : dependencies) {
        if (dependency.dependencyType == "together") {
            if (avoidMap[dependency.primaryCrop].count(dependency.dependentCrop)) {
                cout << "Conflict detected: " << dependency.primaryCrop << " and "
                     << dependency.dependentCrop << " cannot be both together and avoid.\n";
                conflict = true;
            }
            togetherMap[dependency.primaryCrop].insert(dependency.dependentCrop);
            togetherMap[dependency.dependentCrop].insert(dependency.primaryCrop);
        } else if (dependency.dependencyType == "avoid") {
            if (togetherMap[dependency.primaryCrop].count(dependency.dependentCrop)) {
                cout << "Conflict detected: " << dependency.primaryCrop << " and "
                     << dependency.dependentCrop << " cannot be both together and avoid.\n";
                conflict = true;
            }
            avoidMap[dependency.primaryCrop].insert(dependency.dependentCrop);
            avoidMap[dependency.dependentCrop].insert(dependency.primaryCrop);
        }
    }

    return conflict;
}

// Function to provide recommendations based on dependencies
void provideRecommendations(const vector<CropDependency>& dependencies) {
    cout << "\nRecommendations:\n";
    for (const auto& dependency : dependencies) {
        if (dependency.dependencyType == "together") {
            cout << "- Plant " << dependency.primaryCrop << " and " << dependency.dependentCrop << " together.\n";
        } else if (dependency.dependencyType == "avoid") {
            cout << "- Avoid planting " << dependency.primaryCrop << " and " << dependency.dependentCrop << " together.\n";
        }
    }
}

void manageCropDependencies() {
    int numCrops, numDependencies;

    cout << "Manage Crop Dependencies\n";
    cout << "This function helps manage dependencies between different crops for optimal growth.\n";

    cout << "Enter the number of crops: ";
    while (!(cin >> numCrops) || numCrops <= 0) {
        cin.clear(); // Clear the error flag
        cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
        cout << "Invalid number of crops. Please enter a positive value: ";
    }

    cout << "Enter the number of dependencies: ";
    while (!(cin >> numDependencies) || numDependencies <= 0) {
        cin.clear(); // Clear the error flag
        cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
        cout << "Invalid number of dependencies. Please enter a positive value: ";
    }

    vector<CropDependency> dependencies;

    for (int i = 1; i <= numDependencies; ++i) {
        string primaryCrop, dependentCrop, dependencyType;

        cout << "\nEntering details for Dependency " << i << ":\n";
        cout << "Enter primary crop: ";
        cin >> primaryCrop;
        cout << "Enter dependent crop: ";
        cin >> dependentCrop;

        cout << "Enter dependency type (together/avoid): ";
        cin >> dependencyType;
        while (dependencyType != "together" && dependencyType != "avoid") {
            cin.clear(); // Clear the error flag
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
            cout << "Invalid dependency type. Please enter 'together' or 'avoid': ";
            cin >> dependencyType;
        }

        dependencies.emplace_back(primaryCrop, dependentCrop, dependencyType);
    }

    displayCropDependencies(dependencies);

    bool conflict = checkForConflicts(dependencies);
    if (!conflict) {
        cout << "\nNo conflicts detected.";
    }

    provideRecommendations(dependencies);
}
// Function to maximize farm yield using dynamic programming
int maximizeFarmYield(const vector<int>& yields, const vector<int>& area, int totalArea) {
    int n = yields.size();
    vector<vector<int>> dp(n + 1, vector<int>(totalArea + 1, 0));

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= totalArea; j++) {
            if (area[i - 1] <= j) { // If the current crop's area can fit
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - area[i - 1]] + yields[i - 1]);
            } else {
                dp[i][j] = dp[i - 1][j]; // Exclude the crop
            }
        }
    }

    return dp[n][totalArea]; // Maximum yield
}

// Function to maximize harvest schedule using dynamic programming
struct HarvestSchedule {
    string cropName;
    string harvestDate;
    string instructions;

    HarvestSchedule(string name, string date, string instr) : cropName(name), harvestDate(date), instructions(instr) {}
};

// Function to display the harvest schedule
void displayHarvestSchedule(const vector<HarvestSchedule>& schedule) {
    cout << "\nHarvest Schedule (Sorted by Date):\n";
    for (size_t i = 0; i < schedule.size(); ++i) {
        cout << i + 1 << ". " << schedule[i].cropName
             << " - Expected Harvest Date: " << schedule[i].harvestDate
             << "\n   Special Instructions: " << schedule[i].instructions << "\n";
    }
}

// Function to sort the harvest schedule by date
void sortHarvestSchedule(vector<HarvestSchedule>& schedule) {
    sort(schedule.begin(), schedule.end(), [](const HarvestSchedule& a, const HarvestSchedule& b) {
        return a.harvestDate < b.harvestDate;
    });
}

// Function to display upcoming harvests
void displayUpcomingHarvests(const vector<HarvestSchedule>& schedule) {
    cout << "\nUpcoming Harvests:\n";
    for (const auto& crop : schedule) {
        cout << "- " << crop.cropName << ": " << crop.harvestDate << "\n";
    }
}

void manageHarvestSchedule() {
    int numCrops;

    cout << "Manage Harvest Schedule\n";
    cout << "This function helps manage the harvest schedule for different crops.\n";

    cout << "Enter the number of crops: ";
    while (!(cin >> numCrops) || numCrops <= 0) {
        cin.clear(); // Clear the error flag
        cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
        cout << "Invalid number of crops. Please enter a positive value: ";
    }

    vector<HarvestSchedule> schedule;

    for (int i = 1; i <= numCrops; ++i) {
        string cropName, harvestDate, instructions;

        cout << "\nEntering details for Crop " << i << ":\n";
        cout << "Enter crop name: ";
        cin >> cropName;

        cout << "Enter expected harvest date (YYYY-MM-DD): ";
        cin >> harvestDate;

        cout << "Enter special instructions: ";
        cin.ignore();
        getline(cin, instructions);

        schedule.emplace_back(cropName, harvestDate, instructions);
    }

    // Sort the harvest schedule by date
    sortHarvestSchedule(schedule);

    // Display the sorted harvest schedule
    displayHarvestSchedule(schedule);

    // Display upcoming harvests
    displayUpcomingHarvests(schedule);
}

// Function to maximize profit from crops using dynamic programming
int cropProfitMaximization(const vector<int>& profits, const vector<int>& areas, int totalArea) {
    int n = profits.size();
    vector<vector<int>> dp(n + 1, vector<int>(totalArea + 1, 0));

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= totalArea; j++) {
            if (areas[i - 1] <= j) {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - areas[i - 1]] + profits[i - 1]);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    return dp[n][totalArea]; // Return maximum profit
}

// Structure to hold crop rotation benefit properties
struct CropRotationBenefit {
    string cropName;
    double nutrientReplenishment; // Nutrient replenishment value
    double pestControl; // Pest control value

    CropRotationBenefit() : cropName(""), nutrientReplenishment(0), pestControl(0) {}
    CropRotationBenefit(string name, double nutrient, double pest) : cropName(name), nutrientReplenishment(nutrient), pestControl(pest) {}
};

// Function to calculate and display crop rotation benefits
void calculateCropRotationBenefits(const vector<CropRotationBenefit>& crops) {
    cout << "\nCrop Rotation Benefits:\n";
    for (const auto& crop : crops) {
        double benefitScore = crop.nutrientReplenishment * crop.pestControl;
        cout << "Crop: " << crop.cropName << ", Benefit Score: " << benefitScore << endl;
    }

    // Provide actionable insights
    cout << "\nRecommendations for Crop Rotation:\n";
    for (const auto& crop : crops) {
        if (crop.nutrientReplenishment < 5) {
            cout << "Crop: " << crop.cropName << " - Consider rotating with leguminous crops to improve soil fertility.\n";
        }
        if (crop.pestControl < 5) {
            cout << "Crop: " << crop.cropName << " - Implement integrated pest management strategies.\n";
        }
    }
}
// Function to gather crop rotation benefit data from user input
void gatherCropRotationBenefitData(vector<CropRotationBenefit>& crops, int numCrops) {
    for (int i = 1; i <= numCrops; ++i) {
        string name;
        double nutrient, pest;

        cout << "\nEntering details for Crop " << i << ":\n";
        cout << "Crop Name: ";
        cin >> name;
        cout << "Nutrient Replenishment Value: ";
        cin >> nutrient;
        cout << "Pest Control Value: ";
        cin >> pest;

        // Create a CropRotationBenefit object and add it to the vector
        crops.emplace_back(name, nutrient, pest);
    }
}
// Structure to hold soil erosion risk properties
struct SoilErosionRisk {
    string soilType;
    double slope; // Slope percentage
    double rainfall; // Rainfall amount (mm)

    SoilErosionRisk() : soilType(""), slope(0), rainfall(0) {}
    SoilErosionRisk(string type, double slopeVal, double rain) : soilType(type), slope(slopeVal), rainfall(rain) {}
};

// Function to calculate soil erosion risk
void analyzeSoilErosionRisk(const vector<SoilErosionRisk>& samples) {
    cout << "\nSoil Erosion Risk Analysis:\n";
    for (const auto& sample : samples) {
        double erosionRisk = sample.slope * sample.rainfall;
        cout << "Soil Type: " << sample.soilType << ", Erosion Risk: " << erosionRisk << endl;
    }

    // Provide actionable insights
    cout << "\nRecommendations for Soil Erosion Mitigation:\n";
    for (const auto& sample : samples) {
        if (sample.slope > 10) {
            cout << "Soil Type: " << sample.soilType << " - Consider using terracing or ground cover plants to reduce erosion.\n";
        }
        if (sample.rainfall > 100) {
            cout << "Soil Type: " << sample.soilType << " - Ensure proper drainage systems to manage excess water.\n";
        }
    }
}

// Function to gather soil erosion risk data from user input
void gatherSoilErosionRiskData(vector<SoilErosionRisk>& samples, int numSamples) {
    for (int i = 1; i <= numSamples; ++i) {
        string type;
        double slope, rainfall;

        cout << "\nEntering details for Soil Sample " << i << ":\n";
        cout << "Soil Type: ";
        cin >> type;
        cout << "Slope (%): ";
        cin >> slope;
        cout << "Rainfall (mm): ";
        cin >> rainfall;

        // Create a SoilErosionRisk object and add it to the vector
        samples.emplace_back(type, slope, rainfall);
    }
}

// Function to find the optimal way to partition land among different crops
int optimalLandPartitioning(const vector<int>& yields, const vector<int>& areas, int totalArea) {
    int n = yields.size();
    vector<vector<int>> dp(n + 1, vector<int>(totalArea + 1, 0));

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= totalArea; j++) {
            if (areas[i - 1] <= j) {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - areas[i - 1]] + yields[i - 1]);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    return dp[n][totalArea]; // Return total yield
}
void manageOptimalLandPartitioning() {
    int n, totalArea;

    cout << "Enter number of crops: ";
    cin >> n;

    vector<int> yields(n), areas(n);

    cout << "Enter yields and areas for each crop:\n";
    for (int i = 0; i < n; i++) {
        cout << "Crop " << i + 1 << " yield: ";
        cin >> yields[i];
        cout << "Crop " << i + 1 << " area: ";
        cin >> areas[i];
    }

    cout << "Enter total available area: ";
    cin >> totalArea;

    int totalYield = optimalLandPartitioning(yields, areas, totalArea);
    cout << "Total Yield with Optimal Partitioning: " << totalYield << endl;

    // Provide actionable insights
    cout << "\nRecommendations for Optimal Land Partitioning:\n";
    for (int i = 0; i < n; i++) {
        if (areas[i] > totalArea / n) {
            cout << "Crop " << i + 1 << " - Consider reducing area or using vertical farming techniques to optimize space.\n";
        }
    }
}

// Function to allocate nutrients based on real-time data
void allocateNutrientsDynamically(const vector<double>& nutrientNeeds, const vector<double>& nutrientSupplies,
                                   vector<double>& allocations) {
    double totalDemand = 0, totalSupply = 0;

    // Calculate total demand and total supply
    for (double need : nutrientNeeds) {
        totalDemand += need;
    }
    for (double supply : nutrientSupplies) {
        totalSupply += supply;
    }

    // Allocate nutrients based on proportional needs
    for (size_t i = 0; i < nutrientNeeds.size(); i++) {
        if (totalDemand > 0) {
            allocations[i] = (nutrientNeeds[i] / totalDemand) * min(totalSupply, totalDemand);
        } else {
            allocations[i] = 0; // No needs
        }
    }
}

void manageNutrientAllocation() {
    int n;

    cout << "Enter number of crops/nutritional needs: ";
    cin >> n;

    vector<double> nutrientNeeds(n), nutrientSupplies(n), allocations(n, 0);

    cout << "Enter nutrient needs and supplies for each crop:\n";
    for (int i = 0; i < n; i++) {
        cout << "Crop " << i + 1 << " nutrient need: ";
        cin >> nutrientNeeds[i];
        cout << "Crop " << i + 1 << " nutrient supply: ";
        cin >> nutrientSupplies[i];
    }

    allocateNutrientsDynamically(nutrientNeeds, nutrientSupplies, allocations);

    cout << "Nutrient Allocations:\n";
    for (int i = 0; i < n; i++) {
        cout << "Crop " << i + 1 << " allocated nutrients: " << allocations[i] << endl;
    }

    // Provide actionable insights
    cout << "\nRecommendations for Nutrient Allocation:\n";
    for (int i = 0; i < n; i++) {
        if (allocations[i] < nutrientNeeds[i] * 0.8) {
            cout << "Crop " << i + 1 << " - Consider using nutrient-dense mediums or adding supplements.\n";
        }
    }
}

void manageIrrigationSystems() {
    int vertices, edges;

    cout << "Enter the number of vertices in the irrigation system: ";
    cin >> vertices;

    MaxFlow maxFlow(vertices);

    cout << "Enter the number of edges: ";
    cin >> edges;

    for (int i = 0; i < edges; i++) {
        int u, v, cap;
        cout << "Enter edge (u, v) and capacity: ";
        cin >> u >> v >> cap;
        maxFlow.addEdge(u, v, cap);
    }

    int source, sink;
    cout << "Enter source and sink vertices: ";
    cin >> source >> sink;

    int result = maxFlow.edmondsKarp(source, sink);
    cout << "Maximum flow in the irrigation system: " << result << endl;
}
void manageCropProfitMaximization() {
    int n, totalArea;

    cout << "Enter number of crops: ";
    cin >> n;

    vector<int> profits(n), areas(n);

    cout << "Enter profits and areas for each crop:\n";
    for (int i = 0; i < n; i++) {
        cout << "Crop " << i + 1 << " profit: ";
        cin >> profits[i];
        cout << "Crop " << i + 1 << " area: ";
        cin >> areas[i];
    }

    cout << "Enter total available area: ";
    cin >> totalArea;

    int maxProfit = cropProfitMaximization(profits, areas, totalArea);
    cout << "Maximum Profit from Crops: " << maxProfit << endl;

    // Provide actionable insights
    cout << "\nRecommendations for Crop Profit Maximization:\n";
    for (int i = 0; i < n; i++) {
        if (profits[i] < 500) {
            cout << "Crop " << i + 1 << " - Consider switching to higher-value crops.\n";
        }
    }
}

// Structure to hold crop water requirement properties
struct CropWaterRequirement {
    string cropName;
    double dailyWaterNeed; // Daily water need per hectare (liters)
    int growthStageDays; // Number of days in the growth stage

    CropWaterRequirement(string name, double waterNeed, int days)
        : cropName(name), dailyWaterNeed(waterNeed), growthStageDays(days) {}
};

// Function to calculate total water requirements for crops
double calculateTotalWaterRequirements(const vector<CropWaterRequirement>& crops) {
    double totalWaterRequirement = 0;
    for (const auto& crop : crops) {
        totalWaterRequirement += crop.dailyWaterNeed * crop.growthStageDays;
    }
    return totalWaterRequirement;
}

// Function to gather crop water requirement data from user input
void gatherCropWaterRequirementData(vector<CropWaterRequirement>& crops, int numCrops) {
    for (int i = 1; i <= numCrops; ++i) {
        string name;
        double dailyWaterNeed;
        int growthStageDays;

        cout << "\nEntering details for Crop " << i << ":\n";
        cout << "Crop Name: ";
        cin >> name;
        cout << "Daily Water Need per Hectare (liters): ";
        cin >> dailyWaterNeed;
        cout << "Number of days in the growth stage: ";
        cin >> growthStageDays;

        // Create a CropWaterRequirement object and add it to the vector
        crops.emplace_back(name, dailyWaterNeed, growthStageDays);
    }
}

// Structure to hold soil moisture properties
struct SoilMoisture {
    string sampleID;
    double moistureLevel; // Moisture level as a percentage

    // Default constructor
    SoilMoisture() : sampleID(""), moistureLevel(0.0) {}

    // Parameterized constructor
    SoilMoisture(string id, double level) : sampleID(id), moistureLevel(level) {}
};
// Function to monitor soil moisture and provide irrigation recommendations
void monitorSoilMoisture(const vector<SoilMoisture>& samples) {
    cout << "\nSoil Moisture Monitoring:\n";
    for (const auto& sample : samples) {
        cout << "Sample ID: " << sample.sampleID << ", Moisture Level: " << sample.moistureLevel << "%" << endl;
        if (sample.moistureLevel < 30) {
            cout << "Recommendation: Irrigate immediately. Ensure even distribution of water.\n";
        } else if (sample.moistureLevel < 50) {
            cout << "Recommendation: Monitor closely, consider irrigation soon. Use drip irrigation for efficiency.\n";
        } else {
            cout << "Recommendation: Moisture level is adequate. Maintain current irrigation schedule.\n";
        }
    }
}
// Function to gather soil moisture data from user input
void gatherSoilMoistureData(vector<SoilMoisture>& samples, int numSamples) {
    for (int i = 1; i <= numSamples; ++i) {
        string id;
        double moistureLevel;

        cout << "\nEntering details for Soil Sample " << i << ":\n";
        cout << "Sample ID: ";
        cin >> id;
        cout << "Moisture Level (%): ";
        cin >> moistureLevel;

        // Create a SoilMoisture object and add it to the vector
        samples.emplace_back(id, moistureLevel);
    }
}
// Structure to hold water usage properties for crops
struct WaterUsage {
    string cropName;
    double waterPerHectare; // Water usage per hectare
    double area; // Area in hectares

    // Default constructor
    WaterUsage() : cropName(""), waterPerHectare(0.0), area(0.0) {}

    // Parameterized constructor
    WaterUsage(string name, double water, double a) : cropName(name), waterPerHectare(water), area(a) {}
};

// Function to calculate total water usage based on irrigation schedule and crop requirements
void calculateWaterUsage(const vector<WaterUsage>& crops) {
    double totalWaterUsage = 0;
    for (const auto& crop : crops) {
        totalWaterUsage += crop.waterPerHectare * crop.area;
    }
    cout << "Total Water Usage: " << totalWaterUsage << " liters" << endl;

    // Provide actionable insights
    cout << "\nRecommendations for Water Usage Optimization:\n";
    if (totalWaterUsage > 1000) {
        cout << "Consider using water-saving techniques like mulching and drip irrigation to reduce water usage.\n";
    }
}

// Function to gather water usage data from user input
void gatherWaterUsageData(vector<WaterUsage>& crops, int numCrops) {
    for (int i = 1; i <= numCrops; ++i) {
        string name;
        double water, area;

        cout << "\nEntering details for Crop " << i << ":\n";
        cout << "Crop Name: ";
        cin >> name;
        cout << "Water Required per Hectare (liters): ";
        cin >> water;
        cout << "Area planted with this crop (hectares): ";
        cin >> area;

        // Create a WaterUsage object and add it to the vector
        crops.emplace_back(name, water, area);
    }
}

#include <ctime>

// Structure to hold crop harvest prediction properties
struct CropHarvest {
    string cropName;
    int growthDuration; // Growth duration in days
    tm plantingDate; // Planting date

    CropHarvest(string name, int duration, tm date)
        : cropName(name), growthDuration(duration), plantingDate(date) {}
};

// Function to predict harvest dates for crops
void predictHarvestTime(const vector<CropHarvest>& crops) {
    cout << "\nPredicted Harvest Times:\n";
    for (const auto& crop : crops) {
        tm harvestDate = crop.plantingDate;
        harvestDate.tm_mday += crop.growthDuration;
        mktime(&harvestDate); // Normalize the date

        cout << "Crop: " << crop.cropName
             << ", Harvest Date: " << asctime(&harvestDate);
    }
}

// Function to gather crop harvest prediction data from user input
void gatherCropHarvestData(vector<CropHarvest>& crops, int numCrops) {
    for (int i = 1; i <= numCrops; ++i) {
        string name;
        int growthDuration;
        int year, month, day;

        cout << "\nEntering details for Crop " << i << ":\n";
        cout << "Crop Name: ";
        cin >> name;
        cout << "Growth Duration (days): ";
        cin >> growthDuration;

        cout << "Enter Planting Date (YYYY MM DD): ";
        cin >> year >> month >> day;

        tm plantingDate = {};
        plantingDate.tm_year = year - 1900; // tm_year is years since 1900
        plantingDate.tm_mon = month - 1;    // tm_mon is 0-based
        plantingDate.tm_mday = day;

        // Create a CropHarvest object and add it to the vector
        crops.emplace_back(name, growthDuration, plantingDate);
    }
}
// Function to solve the nutrient subset problem using subset-sum
bool solveNutrientSubsetProblem(const vector<int>& nutrients, int requiredNutrient) {
    int n = nutrients.size();
    vector<vector<bool>> dp(n + 1, vector<bool>(requiredNutrient + 1, false));

    // Initialize the dp array
    for (int i = 0; i <= n; i++) {
        dp[i][0] = true;
    }

    // Fill the dp array
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= requiredNutrient; j++) {
            if (nutrients[i - 1] <= j) {
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nutrients[i - 1]];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    return dp[n][requiredNutrient];
}

// Function to gather nutrient data from user input and solve the problem
void gatherAndSolveNutrientSubsetProblem() {
    int numNutrients, requiredNutrient;

    cout << "Enter the number of nutrients available: ";
    cin >> numNutrients;

    vector<int> nutrients(numNutrients);
    cout << "Enter the nutrient values:\n";
    for (int i = 0; i < numNutrients; i++) {
        cin >> nutrients[i];
    }

    cout << "Enter the required nutrient value: ";
    cin >> requiredNutrient;

    bool result = solveNutrientSubsetProblem(nutrients, requiredNutrient);
    if (result) {
        cout << "It is possible to match the required nutrient value using the available nutrients.\n";
    } else {
        cout << "It is not possible to match the required nutrient value using the available nutrients.\n";
    }

    // Provide actionable insights
    cout << "\nRecommendations for Nutrient Management:\n";
    if (!result) {
        cout << "Consider using nutrient supplements to meet the required nutrient value.\n";
        cout << "Ensure balanced nutrient levels by regularly testing and adjusting the nutrient solution.\n";
    }
}
// Function to evaluate undecidable resource allocation plans
void evaluateUndecidablePlans(const vector<int>& resourceDemands, int totalResources) {
    int n = resourceDemands.size();
    int sumDemands = accumulate(resourceDemands.begin(), resourceDemands.end(), 0);

    cout << "\nEvaluating Undecidable Plans:\n";
    if (sumDemands > totalResources) {
        cout << "The total resource demands exceed the available resources. Allocation is undecidable.\n";
    } else {
        cout << "The total resource demands can be met with the available resources. Allocation is possible.\n";
    }
}

// Function to gather resource demands and evaluate plans
void gatherAndEvaluateUndecidablePlans() {
    int numResources, totalResources;

    cout << "Enter the number of resource demands: ";
    cin >> numResources;

    vector<int> resourceDemands(numResources);
    cout << "Enter the resource demand values:\n";
    for (int i = 0; i < numResources; i++) {
        cin >> resourceDemands[i];
    }

    cout << "Enter the total available resources: ";
    cin >> totalResources;

    evaluateUndecidablePlans(resourceDemands, totalResources);

    // Provide actionable insights
    cout << "\nRecommendations for Resource Allocation:\n";
    if (accumulate(resourceDemands.begin(), resourceDemands.end(), 0) > totalResources) {
        cout << "The total resource demands exceed the available resources. Consider prioritizing essential resources or finding additional sources.\n";
    } else {
        cout << "The total resource demands can be met with the available resources. Ensure efficient allocation to avoid shortages.\n";
    }
}
struct EnvironmentalData {
    double temperature;
    double humidity;
    double lightLevel;
};

void monitorEnvironmentalData(const vector<EnvironmentalData>& data) {
    cout << "\nReal-Time Environmental Data Monitoring:\n";
    for (const auto& datum : data) {
        cout << "Temperature: " << datum.temperature << "C, Humidity: " << datum.humidity << "%, Light Level: " << datum.lightLevel << " lux" << endl;

        // Provide actionable insights
        if (datum.temperature < 18) {
            cout << "Recommendation: Increase temperature to optimize plant growth.\n";
        } else if (datum.temperature > 30) {
            cout << "Recommendation: Decrease temperature to prevent plant stress.\n";
        }

        if (datum.humidity < 40) {
            cout << "Recommendation: Increase humidity to improve plant hydration.\n";
        } else if (datum.humidity > 70) {
            cout << "Recommendation: Decrease humidity to prevent fungal diseases.\n";
        }

        if (datum.lightLevel < 10000) {
            cout << "Recommendation: Increase light exposure to enhance photosynthesis.\n";
        } else if (datum.lightLevel > 20000) {
            cout << "Recommendation: Decrease light exposure to prevent plant burn.\n";
        }
    }
}
struct PestData {
    string pestType;
    int severityLevel; // Scale from 1 to 10
};

void managePestControl(const vector<PestData>& pestData) {
    cout << "\nPest Control Management:\n";
    for (const auto& data : pestData) {
        cout << "Pest Type: " << data.pestType << ", Severity Level: " << data.severityLevel << "/10" << endl;

        // Provide actionable insights
        if (data.severityLevel > 7) {
            cout << "Recommendation: Implement immediate pest control measures using organic pesticides or integrated pest management (IPM) techniques.\n";
        } else if (data.severityLevel > 4) {
            cout << "Recommendation: Monitor the pest population closely and use preventive measures such as traps and natural predators.\n";
        } else {
            cout << "Recommendation: Maintain regular monitoring and use cultural practices to prevent pest buildup.\n";
        }
    }
}




#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <limits>
#include <string>
#include <map>
#include <stack>
#include <algorithm>

using namespace std;

// Define FoodItem struct
// Structure to represent a food item with its name, shelf life, and demand
struct FoodItem {
    string name;
    int shelfLife;
    int demand;

    // Default constructor
    FoodItem() : name(""), shelfLife(0), demand(0) {}

    // Parameterized constructor
    FoodItem(string n, int s, int d) : name(n), shelfLife(s), demand(d) {}
};

// Function Prototypes for all the tasks
void calculateOptimalWaterUsage();
void manageSoilHealth();
void minimizeEnergyConsumption();
void manageOrganicWaste();
void determineShortestPath();
void trackCropSpecies();
void manageCropDistribution();
void simulateTemperatureChanges(int rows, int cols);
void managePestEcosystem();
void simulateWaterFiltration();
void simulateWastewaterRecycling();
void manageCommunityNetwork();
void manageResourcesAndJobs();
void manageNutrientCycle();
void optimizeFarmingSchedule();
void optimizeResourceRouting();
void climateChangeAdaptation();
void prioritizeWasteToEnergy();
int optimizeFoodDistribution(const vector<FoodItem>& foodItems, int maxDays);
void optimizeGreenSpaceAllocation();

// Structure to represent a crop with its demand and availability
struct Crop1 {
    string name;
    int demand;
    int availability;

    // Default constructor
    Crop1() : name(""), demand(0), availability(0) {}

    // Parameterized constructor
    Crop1(string n, int d, int a) : name(n), demand(d), availability(a) {}

    // Overload the less-than operator for priority queue to prioritize higher demand
    bool operator<(const Crop1& other) const {
        return demand < other.demand;
    }
};

// Helper function to read crop data
Crop1 readCropData(int cropIndex) {
    string name;
    int demand, availability;
    cout << "Enter the name of crop " << cropIndex + 1 << ": ";
    cin >> name;
    cout << "Enter the demand for " << name << ": ";
    cin >> demand;
    cout << "Enter the availability of " << name << ": ";
    cin >> availability;
    return Crop1(name, demand, availability);
}

// Function to manage crop distribution
void manageCropDistribution() {
    priority_queue<Crop1> cropQueue;
    int numCrops;

    cout << "Enter the number of crops: ";
    cin >> numCrops;

    if (numCrops <= 0) {
        cout << "Number of crops must be positive." << endl;
        return;
    }

    for (int i = 0; i < numCrops; ++i) {
        Crop1 crop1 = readCropData(i);
        cropQueue.push(crop1);
    }

    cout << "\nCrop Distribution Based on Demand:\n";
    while (!cropQueue.empty()) {
        Crop1 crop1 = cropQueue.top();
        cropQueue.pop();
        cout << "Distributing " << crop1.name << " with demand " << crop1.demand << " and availability " << crop1.availability << endl;
    }
}

// Helper function to read water and soil data for a crop
void readWaterAndSoilData(vector<Crop1>& crops1, vector<double>& soilMoisture, int cropIndex) {
    cout << "Enter the name of crop " << cropIndex + 1 << ": ";
    cin >> crops1[cropIndex].name;
    cout << "Enter the water requirement (liters per square meter) for " << crops1[cropIndex].name << ": ";
    cin >> crops1[cropIndex].demand; // Assuming waterRequirement is stored in demand for simplicity
    cout << "Enter the soil moisture (percentage) for " << crops1[cropIndex].name << ": ";
    cin >> soilMoisture[cropIndex];
}

// Function to calculate optimal water usage
void calculateOptimalWaterUsage() {
    int numCrops;
    cout << "Enter the number of crops: ";
    cin >> numCrops;

    if (numCrops <= 0) {
        cout << "Number of crops must be positive." << endl;
        return;
    }

    vector<double> soilMoisture(numCrops);
    vector<Crop1> crops1(numCrops);

    for (int i = 0; i < numCrops; ++i) {
        readWaterAndSoilData(crops1, soilMoisture, i);
    }

    vector<double> optimalWaterUsage(numCrops);

    for (size_t i = 0; i < crops1.size(); ++i) {
        // Calculate optimal water usage for each crop
        optimalWaterUsage[i] = max(0.0, static_cast<double>(crops1[i].demand) - soilMoisture[i]);
    }

    cout << "\nOptimal Water Usage for Crops:\n";
    for (size_t i = 0; i < crops1.size(); ++i) {
        cout << crops1[i].name << ": " << optimalWaterUsage[i] << " liters per square meter\n";
    }
}
// Class to manage soil health
// Class to manage soil health parameters and crop rotation
class SoilHealth {
private:
    double phLevel;
    double organicMatter;
    double moistureContent;
    map<string, vector<string>> cropRotationGraph;

    // Helper function to read a positive double value from the user
    double readPositiveDouble(const string& prompt) {
        double value;
        do {
            cout << prompt;
            cin >> value;
            if (value < 0) {
                cout << "Value must be non-negative. Please try again.\n";
            }
        } while (value < 0);
        return value;
    }

    // Helper function to read crop rotation details
    vector<string> readCropRotationDetails(const string& crop) {
        int numFollowingCrops;
        cout << "Enter the number of following crops for " << crop << ": ";
        cin >> numFollowingCrops;

        vector<string> followingCrops(numFollowingCrops);
        for (int i = 0; i < numFollowingCrops; ++i) {
            cout << "Enter the name of following crop " << i + 1 << ": ";
            cin >> followingCrops[i];
        }
        return followingCrops;
    }

public:
    // Default constructor
    SoilHealth() : phLevel(0), organicMatter(0), moistureContent(0) {}

    // Function to input soil health parameters from the user
    void inputSoilHealthParameters() {
        phLevel = readPositiveDouble("Enter soil pH level: ");
        organicMatter = readPositiveDouble("Enter organic matter percentage: ");
        moistureContent = readPositiveDouble("Enter soil moisture content percentage: ");
    }

    // Function to add crop rotation information
    void addCropRotation() {
        string crop;
        cout << "Enter the crop name: ";
        cin >> crop;

        vector<string> followingCrops = readCropRotationDetails(crop);
        cropRotationGraph[crop] = followingCrops;
    }

    // Function to display soil health parameters
    void displaySoilHealth() const {
        cout << "\nSoil Health Parameters:\n";
        cout << "PH Level: " << phLevel << "\n";
        cout << "Organic Matter: " << organicMatter << "%\n";
        cout << "Moisture Content: " << moistureContent << "%\n";
    }

    // Function to display the crop rotation graph
    void displayCropRotationGraph() const {
        cout << "\nCrop Rotation Graph:\n";
        for (const auto& entry : cropRotationGraph) {
            cout << entry.first << " -> ";
            for (const auto& crop : entry.second) {
                cout << crop << " ";
            }
            cout << "\n";
        }
    }
};
// Function to track crop species and their pollinators
// Function to track crop species and their pollinators
void trackCropSpecies() {
    unordered_map<string, vector<string>> cropPollinatorMap;
    string crop, pollinator;

    cout << "Enter crop species and their pollinators (format: crop pollinator, type 'done' to stop):\n";
    while (true) {
        cin >> crop;
        if (crop == "done") break;
        cin >> pollinator;
        cropPollinatorMap[crop].push_back(pollinator);
    }

    cout << "\nCrop Species and their Pollinator Needs:\n";
    for (const auto& pair : cropPollinatorMap) {
        cout << pair.first << ": ";
        for (const auto& pollinator : pair.second) {
            cout << pollinator << " ";
        }
        cout << endl;
    }
}

// Function to manage organic waste for composting
void manageOrganicWaste() {
    queue<string> wasteQueue;
    string waste;

    // Use cin.ignore() to clear the input buffer before using getline
    cout << "Enter organic wastes to add to the queue (type 'done' to stop):\n";
    cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Clear the input buffer before using getline
    while (true) {
        getline(cin, waste);
        if (waste == "done") {
            break;
        }
        wasteQueue.push(waste);
    }

    cout << "\nProcessing organic waste for composting:\n";
    while (!wasteQueue.empty()) {
        cout << "Processing waste: " << wasteQueue.front() << endl;
        wasteQueue.pop();
    }
}

// Function to simulate temperature changes in urban areas with and without farming
void simulateTemperatureChanges(int rows, int cols) {
    vector<vector<double>> urbanArea(rows, vector<double>(cols));
    vector<vector<double>> farmingArea(rows, vector<double>(cols));

    // Helper function to read temperature values for a given area
    auto readTemperatureValues = [](vector<vector<double>>& area, const string& areaName) {
        cout << "Enter the temperature values for the " << areaName << " area:\n";
        for (int i = 0; i < area.size(); ++i) {
            for (int j = 0; j < area[i].size(); ++j) {
                cout << areaName << " area [" << i << "][" << j << "]: ";
                cin >> area[i][j];
            }
        }
    };

    // Read temperature values for both urban and farming areas
    readTemperatureValues(urbanArea, "urban");
    readTemperatureValues(farmingArea, "farming");

    cout << "\nTemperature Analysis:\n";
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            double tempDiff = urbanArea[i][j] - farmingArea[i][j];
            cout << "Temperature difference at [" << i << "][" << j << "]: " << tempDiff << " degrees\n";
        }
    }
}

// Class to manage the water filtration process
class WaterFiltration {
private:
    struct Node {
        string stage;
        double impurities; // Impurities level in percentage
        Node* next;

        Node(string s, double i) : stage(s), impurities(i), next(nullptr) {}
    };

    Node* head;

public:
    WaterFiltration() : head(nullptr) {}

    // Function to add a filtration stage
    void addStage(const string& stage, double impurities) {
        Node* newNode = new Node(stage, impurities);
        if (!head) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
    }

    // Function to simulate the water filtration process
    void simulateFiltration() {
        Node* temp = head;
        cout << "Simulating Water Filtration Process:\n";
        while (temp) {
            cout << "Stage: " << temp->stage << " - Impurities: " << temp->impurities << "%\n";
            if (temp->next) {
                temp->next->impurities = max(0.0, temp->impurities - 10.0); // Example purification logic
            }
            temp = temp->next;
        }
    }

    // Destructor to clean up allocated memory
    ~WaterFiltration() {
        while (head) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }
};

// Function to simulate wastewater recycling
void simulateWastewaterRecycling() {
    queue<string> treatmentQueue;
    string stage;

    cout << "Enter wastewater treatment stages (type 'done' to stop):\n";
    cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Clear the input buffer before using getline
    while (true) {
        getline(cin, stage); // Use getline to handle multi-word inputs
        if (stage == "done") {
            break;
        }
        treatmentQueue.push(stage);
    }

    cout << "\nSimulating Wastewater Recycling Process:\n";
    while (!treatmentQueue.empty()) {
        cout << "Processing stage: " << treatmentQueue.front() << endl;
        treatmentQueue.pop();
    }

    cout << "Wastewater treatment completed. Water stored for irrigation.\n";
}

// Class to manage community engagement network
class CommunityNetwork {
private:
    unordered_map<string, vector<string>> adjList;

public:
    // Function to add a connection between two people
    void addConnection(const string& person1, const string& person2) {
        adjList[person1].push_back(person2);
        adjList[person2].push_back(person1);
    }

    // Function to display all connections in the network
    void displayConnections() {
        cout << "\nCommunity Engagement Network:\n";
        for (const auto& entry : adjList) {
            cout << entry.first << " is connected to: ";
            for (const auto& person : entry.second) {
                cout << person << " ";
            }
            cout << endl;
        }
    }

    // Function to track participation of a specific person
    void trackParticipation(const string& person) {
        if (adjList.find(person) != adjList.end()) {
            cout << person << " is participating and connected to: ";
            for (const auto& connection : adjList[person]) {
                cout << connection << " ";
            }
            cout << endl;
        } else {
            cout << person << " is not found in the network.\n";
        }
    }
};

// Structure to represent a resource or job with its demand
struct Resource1 {
    string name;
    int demand;

    Resource1() : name(""), demand(0) {} // Default constructor
    Resource1(string n, int d) : name(n), demand(d) {}

    // Overload the less-than operator for priority queue to prioritize higher demand
    bool operator<(const Resource1& other) const {
        return demand < other.demand;
    }
};

// Function to manage resources and jobs
void manageResourcesAndJobs() {
    priority_queue<Resource1> resourceQueue;
    int numResources;

    cout << "Enter the number of resources/jobs: ";
    cin >> numResources;
    cin.ignore();  // To ignore the remaining newline character from previous input

    for (int i = 0; i < numResources; ++i) {
        string name;
        int demand;
        cout << "Enter the name of resource/job " << i + 1 << ": ";
        getline(cin, name); // Use getline to avoid issues with spaces in names
        cout << "Enter the demand for " << name << ": ";
        cin >> demand;
        cin.ignore(); // Ignore the newline character
        resourceQueue.push(Resource1(name, demand));
    }

    cout << "\nResource and Job Allocation Based on Demand:\n";
    while (!resourceQueue.empty()) {
        Resource1 resource1 = resourceQueue.top();
        resourceQueue.pop();
        cout << "Allocating " << resource1.name << " with demand " << resource1.demand << endl;
    }
}

// Class to represent nutrient node in a circular linked list
class NutrientNode {
public:
    string part;
    double nutrientLevel;
    NutrientNode* next;

    NutrientNode(string p, double n) : part(p), nutrientLevel(n), next(nullptr) {}
};

// Class to represent nutrient cycle using circular linked list
class NutrientCycle {
private:
    NutrientNode* head;

public:
    NutrientCycle() : head(nullptr) {}

    // Function to add a new part to the nutrient cycle
    void addPart(const string& part, double nutrientLevel) {
        NutrientNode* newNode = new NutrientNode(part, nutrientLevel);
        if (!head) {
            head = newNode;
            head->next = head; // Circular link to itself
        } else {
            NutrientNode* temp = head;
            while (temp->next != head) {
                temp = temp->next;
            }
            temp->next = newNode;
            newNode->next = head; // Circular link back to head
        }
    }

    // Function to display nutrient flow in the cycle
    void displayNutrientFlow() {
        if (!head) {
            cout << "No parts in the nutrient cycle.\n";
            return;
        }

        NutrientNode* temp = head;
        cout << "\nNutrient Flow in the Farming System:\n";
        do {
            cout << "Part: " << temp->part << " - Nutrient Level: " << temp->nutrientLevel << "%\n";
            temp = temp->next;
        } while (temp != head);
    }

    // Destructor to clean up allocated memory
    ~NutrientCycle() {
        if (!head) return;

        NutrientNode* temp = head;
        do {
            NutrientNode* nextNode = temp->next;
            delete temp;
            temp = nextNode;
        } while (temp != head);
    }
};

// Structure to represent a farming activity with its carbon emission
struct FarmingActivity {
    string name;
    int startTime;
    int endTime;
    int carbonEmission;

    FarmingActivity(string n, int s, int e, int ce) : name(n), startTime(s), endTime(e), carbonEmission(ce) {}
};

// Function to optimize farming schedule to reduce carbon emissions using dynamic programming
int optimizeFarmingSchedule(vector<FarmingActivity>& activities) {
    int n = activities.size();
    vector<int> dp(n, 0);

    // Sort activities based on end time
    sort(activities.begin(), activities.end(), [](FarmingActivity& a, FarmingActivity& b) {
        return a.endTime < b.endTime;
    });

    dp[0] = activities[0].carbonEmission;

    for (int i = 1; i < n; ++i) {
        int inclEmission = activities[i].carbonEmission;
        int l = -1;
        for (int j = i - 1; j >= 0; --j) {
            if (activities[j].endTime <= activities[i].startTime) {
                l = j;
                break;
            }
        }

        if (l != -1) {
            inclEmission += dp[l];
        }

        dp[i] = min(inclEmission, dp[i - 1]);
    }

    return dp[n - 1];
}

// Structure to represent a weighted edge in a graph
struct Edge1 {
    int to;
    double weight;

    Edge1() : to(0), weight(0) {} // Default constructor
    Edge1(int t, double w) : to(t), weight(w) {}
};

// Function to add an edge to the graph
void addEdge(unordered_map<int, vector<Edge1>>& graph, int from, int to, double weight) {
    graph[from].push_back({to, weight});
    graph[to].push_back({from, weight}); // Assuming it's an undirected graph
}

// Function to find the shortest path using Dijkstra's algorithm
vector<double> dijkstra(const unordered_map<int, vector<Edge1>>& graph, int start, int n) {
    vector<double> dist(n, numeric_limits<double>::max());
    dist[start] = 0.0;

    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq;
    pq.push({0.0, start});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if (d > dist[u]) continue;

        for (const auto& edge1 : graph.at(u)) {
            int v = edge1.to;
            double weight = edge1.weight;

            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }

    return dist;
}

// Function to optimize resource routing
void optimizeResourceRouting() {
    unordered_map<int, vector<Edge1>> graph;
    int n, m;

    cout << "Enter the number of nodes: ";
    cin >> n;
    cout << "Enter the number of edges: ";
    cin >> m;

    cout << "Enter the edges (format: from to weight):\n";
    for (int i = 0; i < m; ++i) {
        int from, to;
        double weight;
        cin >> from >> to >> weight;
        addEdge(graph, from, to, weight);
    }

    int start;
    cout << "Enter the starting node: ";
    cin >> start;

    vector<double> distances = dijkstra(graph, start, n);

    cout << "\nShortest distances from node " << start << ":\n";
    for (int i = 0; i < n; ++i) {
        cout << "To node " << i << ": " << distances[i] << " units\n";
    }
}

// Structure to represent a decision tree node
struct TreeNode {
    string question;
    string practice;
    TreeNode* yesBranch;
    TreeNode* noBranch;

    TreeNode(const string& q, const string& p = "") : question(q), practice(p), yesBranch(nullptr), noBranch(nullptr) {}
};

// Function to build the decision tree
TreeNode* buildDecisionTree() {
    // Constructing a simple decision tree for climate change adaptation
    TreeNode* root = new TreeNode("Is it raining?");
    root->yesBranch = new TreeNode("Is the soil already wet?", "Delay watering");
    root->noBranch = new TreeNode("Is it sunny?", "Water the plants early in the morning");

    root->yesBranch->yesBranch = new TreeNode("", "No additional watering needed");
    root->yesBranch->noBranch = new TreeNode("", "Water lightly to avoid over-saturation");

    root->noBranch->yesBranch = new TreeNode("", "Increase watering frequency");
    root->noBranch->noBranch = new TreeNode("", "Monitor soil moisture and water as needed");

    return root;
}

// Function to traverse the decision tree based on user input
string determineBestPractice(TreeNode* node) {
    while (node->yesBranch || node->noBranch) {
        cout << node->question << " (yes/no): ";
        string answer;
        cin >> answer;

        if (answer == "yes") {
            node = node->yesBranch;
        } else if (answer == "no") {
            node = node->noBranch;
        } else {
            cout << "Invalid input. Please answer with 'yes' or 'no'.\n";
        }
    }

    return node->practice;
}

// Function for climate change adaptation using decision tree
void climateChangeAdaptation() {
    TreeNode* root = buildDecisionTree();
    string bestPractice = determineBestPractice(root);
    cout << "Best farming practice: " << bestPractice << endl;

    // Cleanup: Free the allocated memory
    delete root->yesBranch->yesBranch;
    delete root->yesBranch->noBranch;
    delete root->yesBranch;
    delete root->noBranch->yesBranch;
    delete root->noBranch->noBranch;
    delete root;
}


// Function Definitions
void manageSoilHealth() {
    cout << "Managing soil health...\n";
}

void minimizeEnergyConsumption() {
    cout << "Minimizing energy consumption...\n";
}

void determineShortestPath() {
    cout << "Determining shortest path...\n";
}

void managePestEcosystem() {
    cout << "Managing pest ecosystem...\n";
}

void simulateWaterFiltration() {
    cout << "Simulating water filtration...\n";
}

void manageCommunityNetwork() {
    cout << "Managing community network...\n";
}

void manageNutrientCycle() {
    cout << "Managing nutrient cycle...\n";
}

void optimizeFarmingSchedule() {
    cout << "Optimizing farming schedule...\n";
}

void prioritizeWasteToEnergy() {
    cout << "Prioritizing waste-to-energy...\n";
}



int optimizeFoodDistribution(const vector<FoodItem>& foodItems, int maxDays) {
    int maxUsage = 0;
    for (const auto& item : foodItems) {
        if (item.shelfLife <= maxDays) {
            maxUsage += item.demand;
        }
    }
    return maxUsage;
}

void optimizeGreenSpaceAllocation() {
    cout << "Optimizing green space allocation...\n";
}





#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <ctime>
#include <cstdlib>
#include <iomanip>
#include <queue>
#include <limits>
#include <algorithm> // For std::reverse

// Base structure for a Crop
struct Crop2
    {
    std::string name;
    int maturityDays;
    int currentGrowth;
    std::string plantingDate;
    std::string harvestStartDate; // Start date for harvest range
    std::string harvestEndDate;   // End date for harvest range (5 days after harvest start)
    double yieldPerAcre;          // Expected yield per acre
    double totalYield;            // Total yield

    Crop2(std::string n, int m, std::string p, double y = 0.0) :
    name(n), maturityDays(m), currentGrowth(0), plantingDate(p), yieldPerAcre(y), totalYield(0)
    {
        calculateHarvestDates(p, m); // Automatically calculate harvest date range
    }

    // Helper function to calculate harvest start and end dates
    void calculateHarvestDates(const std::string& plantingDate, int maturityDays)
    {
        int year = std::stoi(plantingDate.substr(0, 4));
        int month = std::stoi(plantingDate.substr(5, 2));
        int day = std::stoi(plantingDate.substr(8, 2));

        day += maturityDays;
        while (day > 30)
        {
            day -= 30;
            month++;
            if (month > 12)
            {
                month = 1;
                year++;
            }
        }

        harvestStartDate = std::to_string(year) + "-" + (month < 10 ? "0" : "") + std::to_string(month) + "-" + (day < 10 ? "0" : "") + std::to_string(day);

        day += 5;
        while (day > 30)
        {
            day -= 30;
            month++;
            if (month > 12)
            {
                month = 1;
                year++;
            }
        }

        harvestEndDate = std::to_string(year) + "-" + (month < 10 ? "0" : "") + std::to_string(month) + "-" + (day < 10 ? "0" : "") + std::to_string(day);
    }

    // Function to update the current growth status
    void updateGrowth(int days)
    {
        currentGrowth += days;
        if (currentGrowth > maturityDays)
        {
            currentGrowth = maturityDays;
        }
    }

    // Function to check if the crop is ready to be harvested
    bool isHarvestable(const std::string& currentDate)
    {
        return currentDate >= harvestStartDate && currentDate <= harvestEndDate;
    }

    // Function to calculate total yield based on the acreage
    void calculateTotalYield(double acreage)
    {
        totalYield = yieldPerAcre * acreage;
    }

    // Function to display crop information
    void displayInfo() const
    {
        std::cout << "Crop Name: " << name << std::endl;
        std::cout << "Maturity Days: " << maturityDays << std::endl;
        std::cout << "Current Growth: " << currentGrowth << " days" << std::endl;
        std::cout << "Planting Date: " << plantingDate << std::endl;
        std::cout << "Harvest Start Date: " << harvestStartDate << std::endl;
        std::cout << "Harvest End Date: " << harvestEndDate << std::endl;
        std::cout << "Yield per Acre: " << yieldPerAcre << " units" << std::endl;
        std::cout << "Total Yield: " << totalYield << " units" << std::endl;
    }

    // Function to get the remaining growth days
    int getRemainingGrowthDays() const
    {
        return maturityDays - currentGrowth;
    }

    // Function to check if the crop is mature
    bool isMature() const
    {
        return currentGrowth >= maturityDays;
    }

    // Function to simulate a growth period
    void simulateGrowthPeriod(int days)
    {
        updateGrowth(days);
        std::cout << "Simulated " << days << " days of growth. Current growth: " << currentGrowth << " days.\n";
    }

    // Function to reset crop growth
    void resetGrowth()
    {
        currentGrowth = 0;
        std::cout << "Growth reset. Current growth: " << currentGrowth << " days.\n";
    }

    // Function to update planting date and recalculate harvest dates
    void updatePlantingDate(const std::string& newPlantingDate)
    {
        plantingDate = newPlantingDate;
        calculateHarvestDates(newPlantingDate, maturityDays);
        std::cout << "Updated planting date to " << plantingDate << ". New harvest period: " << harvestStartDate << " to " << harvestEndDate << ".\n";
    }

    // New function: Check if the crop is past harvest date
    bool isPastHarvestEndDate(const std::string& currentDate) const
    {
        return currentDate > harvestEndDate;
    }

    // New function: Display detailed harvest information
    void displayHarvestInfo() const
    {
        std::cout << "Harvest Details for " << name << ":\n";
        std::cout << "Harvest Start Date: " << harvestStartDate << "\n";
        std::cout << "Harvest End Date: " << harvestEndDate << "\n";
        std::cout << "Yield per Acre: " << yieldPerAcre << " units\n";
        std::cout << "Total Yield: " << totalYield << " units\n";
    }

    // New function: Calculate and update yield based on actual harvested area
    void updateYieldBasedOnHarvestedArea(double harvestedArea)
    {
        totalYield = yieldPerAcre * harvestedArea;
        std::cout << "Updated total yield based on " << harvestedArea << " acres: " << totalYield << " units.\n";
    }

    // New function: Estimate the harvest time based on current growth
    std::string estimateHarvestTime() const
    {
        int remainingDays = maturityDays - currentGrowth;
        int year = std::stoi(plantingDate.substr(0, 4));
        int month = std::stoi(plantingDate.substr(5, 2));
        int day = std::stoi(plantingDate.substr(8, 2));

        day += remainingDays;
        while (day > 30)
        {
            day -= 30;
            month++;
            if (month > 12)
            {
                month = 1;
                year++;
            }
        }

        return std::to_string(year) + "-" + (month < 10 ? "0" : "") + std::to_string(month) + "-" + (day < 10 ? "0" : "") + std::to_string(day);
    }
};


// Schedule class for harvesting
class HarvestSchedule2
{

private:
    std::vector<Crop2> crops2;
    std::map<std::string, int> transportationAvailability;
    std::string weatherPrediction;
    std::string date; // Store the date entered by the user for harvest schedule

public:

    void addCrop(const std::string& cropName, int maturityDays, const std::string& plantingDate, double yieldPerAcre = 0.0)
    {
        crops2.emplace_back(cropName, maturityDays, plantingDate, yieldPerAcre);
    }

    void updateTransportationAvailability(const std::string& date, int capacity)
    {
        transportationAvailability[date] = capacity;
    }

    void generateHarvestSchedule(const std::string& weather, const std::string& date)
    {
        weatherPrediction = weather; // Save the weather prediction for later use in Option 7
        std::cout << "Generating Harvest Schedule for " << date << " under " << weather << " weather...\n";
        for (const auto& crop2 : crops2)
        {
            std::cout << "Crop: " << crop2.name
                      << ", Planting Date: " << crop2.plantingDate
                      << ", Harvest Period: " << crop2.harvestStartDate << " to " << crop2.harvestEndDate
                      << " (" << (crop2.maturityDays - crop2.currentGrowth)
                      << " days to go)";
            if (weather == "Rainy")
            {
                std::cout << " [Harvesting might be delayed due to rain]";
            }
            std::cout << "\n";
        }
    }

    void displayPlantingSchedule() const
    {
        std::cout << "\n--- Crop Planting Schedule ---\n";
        for (const auto& crop2 : crops2)
        {
            crop2.displayInfo();
        }
    }

    std::string getWeatherPrediction() const
    {
        return weatherPrediction;
    }

    std::vector<Crop2> getCrops() const
    {
        return crops2;
    }

    // New function: Find a crop by name
    Crop2* findCropByName(const std::string& cropName)
    {
        for (auto& crop2 : crops2)
        {
            if (crop2.name == cropName)
            {
                return &crop2;
            }
        }
        return nullptr;
    }

    // New function: Remove a crop by name
    bool removeCropByName(const std::string& cropName)
    {
        auto it = std::remove_if(crops2.begin(), crops2.end(), [&](const Crop2& crop2)
        {
            return crop2.name == cropName;
        });
        if (it != crops2.end())
        {
            crops2.erase(it, crops2.end());
            return true;
        }
        return false;
    }

    // New function: Sort crops by planting date
    void sortCropsByPlantingDate()
    {
        std::sort(crops2.begin(), crops2.end(), [](const Crop2& a, const Crop2& b)
        {
            return a.plantingDate < b.plantingDate;
        });
    }

    // New function: Display transportation availability
    void displayTransportationAvailability() const
    {
        std::cout << "\n--- Transportation Availability ---\n";
        for (const auto& entry : transportationAvailability)
        {
            std::cout << "Date: " << entry.first << ", Capacity: " << entry.second << "\n";
        }
    }

    // New function: Check transportation capacity for a specific date
    int getTransportationCapacity(const std::string& date) const
    {
        auto it = transportationAvailability.find(date);
        if (it != transportationAvailability.end())
        {
            return it->second;
        }
        return 0; // No capacity available for the given date
    }
};

// Crop rotation planner
class CropRotationPlanner
{
private:
    std::map<std::string, std::vector<std::pair<std::string, int>>> cropRotations;

public:
    void addRotationPlan(const std::vector<Crop2>& crops2, const std::string& fieldName)
    {
        std::vector<std::pair<std::string, int>> cropDetails;
        for (const auto& crop2 : crops2)
        {
            cropDetails.emplace_back(crop2.name, crop2.maturityDays);
        }
        cropRotations[fieldName] = cropDetails;
    }

    void displayRotationPlans() const
    {
        if (cropRotations.empty())
        {
            std::cout << "No crop rotation plans available. Please add a rotation plan first.\n";
            return;
        }
        std::cout << "Crop Rotation Plans:\n";
        for (const auto& entry : cropRotations)
        {
            const std::string& fieldName = entry.first;
            const auto& crops = entry.second;

            std::cout << "Field: " << fieldName << " -> Crops:\n";

            int totalMaturityDays = 0;
            for (size_t i = 0; i < crops.size(); ++i)
            {
                size_t next = (i + 1) % crops.size();
                std::cout << crops[i].first << " (" << crops[i].second << " days) -> "
                          << crops[next].first << " (" << crops[next].second << " days)\n";
                totalMaturityDays += crops[i].second;
            }

            int freeDays = 365 - totalMaturityDays;
            if (freeDays > 0) {
                std::cout << "Remaining free days in the year: " << freeDays << " days.\n";
                std::cout << "Benefits of the fallow period:\n"
                          << "- Improves soil health through natural regeneration.\n"
                          << "- Helps in controlling weeds by breaking their growth cycle.\n"
                          << "- Retains soil moisture, reducing the need for irrigation.\n"
                          << "- Enhances soil temperature for better microbial activity.\n"
                          << "- Promotes biodiversity, encouraging beneficial organisms.\n";
            }
            else
            {
                std::cout << "No free days left. All days in the year are occupied by crops.\n";
            }
        }
    }

    // New function: Find rotation plan by field name
    std::vector<std::pair<std::string, int>> findRotationPlanByFieldName(const std::string& fieldName) const {
        auto it = cropRotations.find(fieldName);
        if (it != cropRotations.end())
        {
            return it->second;
        }
        return {}; // Return an empty vector if the field name is not found
    }

    // New function: Remove rotation plan by field name
    bool removeRotationPlanByFieldName(const std::string& fieldName)
    {
        return cropRotations.erase(fieldName) > 0;
    }

    // New function: Update rotation plan for a field
    bool updateRotationPlan(const std::string& fieldName, const std::vector<Crop2>& newCrops)
    {
        auto it = cropRotations.find(fieldName);
        if (it != cropRotations.end())
        {
            std::vector<std::pair<std::string, int>> cropDetails;
            for (const auto& crop2 : newCrops)
            {
                cropDetails.emplace_back(crop2.name, crop2.maturityDays);
            }
            it->second = cropDetails;
            return true;
        }
        return false;
    }

    // New function: List all fields
    void listAllFields() const
    {
        std::cout << "\n--- List of Fields ---\n";
        for (const auto& entry : cropRotations)
        {
            std::cout << "Field: " << entry.first << "\n";
        }
    }

    // New function: Display crop rotation details for a specific field
    void displayRotationPlanForField(const std::string& fieldName) const
    {
        auto it = cropRotations.find(fieldName);
        if (it != cropRotations.end())
        {
            std::cout << "Field: " << fieldName << " -> Crops:\n";
            const auto& crops2 = it->second;
            int totalMaturityDays = 0;
            for (size_t i = 0; i < crops2.size(); ++i)
            {
                size_t next = (i + 1) % crops2.size();
                std::cout << crops2[i].first << " (" << crops2[i].second << " days) -> "
                          << crops2[next].first << " (" << crops2[next].second << " days)\n";
                totalMaturityDays += crops2[i].second;
            }

            int freeDays = 365 - totalMaturityDays;
            if (freeDays > 0)
            {
                std::cout << "Remaining free days in the year: " << freeDays << " days.\n";
                std::cout << "Benefits of the fallow period:\n"
                          << "- Improves soil health through natural regeneration.\n"
                          << "- Helps in controlling weeds by breaking their growth cycle.\n"
                          << "- Retains soil moisture, reducing the need for irrigation.\n"
                          << "- Enhances soil temperature for better microbial activity.\n"
                          << "- Promotes biodiversity, encouraging beneficial organisms.\n";
            }
            else
            {
                std::cout << "No free days left. All days in the year are occupied by crops.\n";
            }
        }
        else
        {
            std::cout << "Field: " << fieldName << " not found.\n";
        }
    }

    // New function: Display summary statistics for all fields
    void displaySummaryStatistics() const
    {
        std::cout << "\n--- Summary Statistics for All Fields ---\n";
        for (const auto& entry : cropRotations)
        {
            const std::string& fieldName = entry.first;
            const auto& crops = entry.second;
            int totalMaturityDays = 0;
            for (const auto& crop : crops)
            {
                totalMaturityDays += crop.second;
            }
            int freeDays = 365 - totalMaturityDays;
            std::cout << "Field: " << fieldName << "\n";
            std::cout << "Total Maturity Days: " << totalMaturityDays << "\n";
            std::cout << "Free Days: " << freeDays << "\n";
        }
    }

    // New function: Find the field with the most free days
    std::string findFieldWithMostFreeDays() const
    {
        std::string fieldWithMostFreeDays;
        int maxFreeDays = -1;
        for (const auto& entry : cropRotations)
        {
            const auto& crops = entry.second;
            int totalMaturityDays = 0;
            for (const auto& crop : crops)
            {
                totalMaturityDays += crop.second;
            }
            int freeDays = 365 - totalMaturityDays;
            if (freeDays > maxFreeDays)
            {
                maxFreeDays = freeDays;
                fieldWithMostFreeDays = entry.first;
            }
        }
        return fieldWithMostFreeDays;
    }
};

// Climate-Adaptive Farming System
class ClimateAdaptiveFarming
{
private:
    std::map<std::string, std::string> cropRecommendations; // Store weather-based crop recommendations
    std::map<std::string, std::vector<std::string>> weatherImpact; // Store weather impact on different crops

public:
    ClimateAdaptiveFarming()
    {
        // Initialize some weather-based crop recommendations
        cropRecommendations["Rainy"] = "Consider planting rice or other water-resistant crops.";
        cropRecommendations["Sunny"] = "Consider planting wheat, corn, or other sun-loving crops.";

        // Initialize some weather impact data
        weatherImpact["Rainy"] = {"Flooding risk", "Increased pest activities"};
        weatherImpact["Sunny"] = {"Drought risk", "Increased irrigation needs"};
    }

    void adjustScheduleForWeather(const std::string& weatherPrediction) const
    {
        std::cout << "Adjusting schedule based on weather prediction: " << weatherPrediction << "\n";

        if (weatherPrediction == "Rainy")
        {
            std::cout << "Harvesting may be delayed due to rain. Prepare for possible rain disruptions.\n";
            if (cropRecommendations.find("Rainy") != cropRecommendations.end())
            {
                std::cout << "Recommendation: " << cropRecommendations.at("Rainy") << "\n";
            }
            if (weatherImpact.find("Rainy") != weatherImpact.end())
            {
                std::cout << "Potential impacts: ";
                for (const auto& impact : weatherImpact.at("Rainy"))
                {
                    std::cout << impact << "; ";
                }
                std::cout << "\n";
            }
        } else if (weatherPrediction == "Sunny")
        {
            std::cout << "Harvesting is possible. Proceed with the plan.\n";
            if (cropRecommendations.find("Sunny") != cropRecommendations.end())
            {
                std::cout << "Recommendation: " << cropRecommendations.at("Sunny") << "\n";
            }
            if (weatherImpact.find("Sunny") != weatherImpact.end())
            {
                std::cout << "Potential impacts: ";
                for (const auto& impact : weatherImpact.at("Sunny"))
                {
                    std::cout << impact << "; ";
                }
                std::cout << "\n";
            }
        }
        else
        {
            std::cout << "Weather condition not recognized. Please check the prediction.\n";
        }
    }

    // New function: Add a new crop recommendation
    void addCropRecommendation(const std::string& weatherCondition, const std::string& recommendation)
    {
        cropRecommendations[weatherCondition] = recommendation;
        std::cout << "Added recommendation for " << weatherCondition << ": " << recommendation << "\n";
    }

    // New function: Add a new weather impact for a specific condition
    void addWeatherImpact(const std::string& weatherCondition, const std::string& impact)
    {
        weatherImpact[weatherCondition].push_back(impact);
        std::cout << "Added weather impact for " << weatherCondition << ": " << impact << "\n";
    }

    // New function: Display all crop recommendations
    void displayCropRecommendations() const
    {
        std::cout << "\n--- Crop Recommendations Based on Weather ---\n";
        for (const auto& entry : cropRecommendations)
        {
            std::cout << "Weather: " << entry.first << ", Recommendation: " << entry.second << "\n";
        }
    }

    // New function: Display all weather impacts
    void displayWeatherImpacts() const
    {
        std::cout << "\n--- Weather Impacts on Crops ---\n";
        for (const auto& entry : weatherImpact)
        {
            std::cout << "Weather: " << entry.first << ", Impacts: ";
            for (const auto& impact : entry.second)
            {
                std::cout << impact << "; ";
            }
            std::cout << "\n";
        }
    }
};

// Graph structure for shortest path algorithm
class Graph
{
private:
    std::map<std::string, std::vector<std::pair<std::string, int>>> adjList;

public:
    void addEdge(const std::string& u, const std::string& v, int weight)
    {
        adjList[u].push_back({v, weight});
        adjList[v].push_back({u, weight}); // Assuming undirected graph
    }

    std::vector<std::string> dijkstra(const std::string& start, const std::string& target)
    {
        std::map<std::string, int> distances;
        std::map<std::string, std::string> previous;
        std::priority_queue<std::pair<int, std::string>, std::vector<std::pair<int, std::string>>, std::greater<>> pq;

        for (const auto& pair : adjList)
        {
            distances[pair.first] = std::numeric_limits<int>::max();
        }
        distances[start] = 0;
        pq.push({0, start});

        while (!pq.empty())
        {
            auto [dist, u] = pq.top();
            pq.pop();

            if (u == target) break;

            for (const auto& [v, weight] : adjList[u])
            {
                int alt = dist + weight;
                if (alt < distances[v])
                {
                    distances[v] = alt;
                    previous[v] = u;
                    pq.push({alt, v});
                }
            }
        }

        std::vector<std::string> path;
        for (std::string at = target; at != ""; at = previous[at]) {
            path.push_back(at);
        }
        std::reverse(path.begin(), path.end());
        return path;
    }

    void displayGraph() const
    {
        for (const auto& pair : adjList)
        {
            std::cout << pair.first << ": ";
            for (const auto& adj : pair.second)
            {
                std::cout << "(" << adj.first << ", " << adj.second << ") ";
            }
            std::cout << "\n";
        }
    }

    // New function: Check if a node exists in the graph
    bool nodeExists(const std::string& node) const
    {
        return adjList.find(node) != adjList.end();
    }

    // New function: Get the neighbors of a node
    std::vector<std::pair<std::string, int>> getNeighbors(const std::string& node) const
    {
        auto it = adjList.find(node);
        if (it != adjList.end())
        {
            return it->second;
        }
        return {}; // Return an empty vector if the node does not exist
    }

    // New function: Remove an edge from the graph
    void removeEdge(const std::string& u, const std::string& v)
    {
        auto removeEdgeFromList = [](auto& list, const std::string& target)
        {
            list.erase(std::remove_if(list.begin(), list.end(),
                [&target](const auto& pair) { return pair.first == target; }), list.end());
        };

        removeEdgeFromList(adjList[u], v);
        removeEdgeFromList(adjList[v], u);
    }

    // New function: Remove a node and its associated edges from the graph
    void removeNode(const std::string& node)
    {
        for (auto& [key, neighbors] : adjList)
        {
            neighbors.erase(std::remove_if(neighbors.begin(), neighbors.end(),
                [&node](const auto& pair) { return pair.first == node; }), neighbors.end());
        }
        adjList.erase(node);
    }

    // New function: Find the shortest path from a start node to all other nodes
    std::map<std::string, int> findShortestPaths(const std::string& start)
    {
        std::map<std::string, int> distances;
        std::priority_queue<std::pair<int, std::string>, std::vector<std::pair<int, std::string>>, std::greater<>> pq;

        for (const auto& pair : adjList)
        {
            distances[pair.first] = std::numeric_limits<int>::max();
        }
        distances[start] = 0;
        pq.push({0, start});

        while (!pq.empty()) {
            auto [dist, u] = pq.top();
            pq.pop();

            for (const auto& [v, weight] : adjList[u])
            {
                int alt = dist + weight;
                if (alt < distances[v])
                {
                    distances[v] = alt;
                    pq.push({alt, v});
                }
            }
        }

        return distances;
    }

    // New function: Display all nodes and their connections
    void displayAllNodes() const
    {
        std::cout << "\n--- All Nodes and Connections ---\n";
        for (const auto& pair : adjList)
        {
            std::cout << "Node: " << pair.first << " -> ";
            for (const auto& adj : pair.second)
            {
                std::cout << adj.first << " (" << adj.second << "), ";
            }
            std::cout << "\n";
        }
    }
};

// Function to check the suitability of the land for the next plantation
void checkLandSuitability()
{
    double soilFertility, nutrientLevels, temperature, waterAvailability, pHLevel, soilType;

    std::cout << "Enter soil fertility level (0-100): ";
    std::cin >> soilFertility;
    std::cout << "Enter nutrient levels (0-100): ";
    std::cin >> nutrientLevels;
    std::cout << "Enter temperature (in Celsius): ";
    std::cin >> temperature;
    std::cout << "Enter water availability (0-100): ";
    std::cin >> waterAvailability;
    std::cout << "Enter soil pH level (0-14): ";
    std::cin >> pHLevel;
    std::cout << "Enter soil type (1 for Sandy, 2 for Clay, 3 for Silt, 4 for Loam): ";
    std::cin >> soilType;

    bool isSuitable = true;
    std::vector<std::string> correctiveActions;

    if (soilFertility < 50)
    {
        std::cout << "Soil fertility is below the required level.\n";
        isSuitable = false;
        correctiveActions.push_back("Improve soil fertility with organic compost or fertilizers.");
    }
    if (nutrientLevels < 50)
    {
        std::cout << "Nutrient levels are insufficient.\n";
        isSuitable = false;
        correctiveActions.push_back("Enhance nutrient levels using appropriate fertilizers.");
    }
    if (temperature < 15 || temperature > 35)
    {
        std::cout << "Temperature is not within the optimal range (15-35C).\n";
        isSuitable = false;
        correctiveActions.push_back("Consider using greenhouses or other temperature control methods.");
    }
    if (waterAvailability < 50)
    {
        std::cout << "Water availability is too low.\n";
        isSuitable = false;
        correctiveActions.push_back("Implement efficient irrigation systems.");
    }
    if (pHLevel < 6 || pHLevel > 7.5)
    {
        std::cout << "Soil pH level is not within the optimal range (6-7.5).\n";
        isSuitable = false;
        correctiveActions.push_back("Adjust soil pH using lime or sulfur as needed.");
    }
    if (soilType != 4)
    { // Assuming 4 (Loam) is the optimal soil type
        std::cout << "Soil type is not optimal. Loam soil is preferred.\n";
        isSuitable = false;
        correctiveActions.push_back("Consider soil amendments to improve soil structure.");
    }

    if (isSuitable)
    {
        std::cout << "The agricultural land is valid for the next plantations.\n";
    }
    else
    {
        std::cout << "The agricultural land is not suitable for the next plantations. Please take corrective actions.\n";
        std::cout << "Recommended corrective actions:\n";
        for (const auto& action : correctiveActions) {
            std::cout << "- " << action << "\n";
        }
    }
}

// Function to track soil test results over time
class SoilTesting
{
private:
    std::map<std::string, std::map<std::string, double>> soilTests;

public:
    void addSoilTestResult(const std::string& date, double fertility, double nutrients, double temperature, double water)
    {
        soilTests[date]["fertility"] = fertility;
        soilTests[date]["nutrients"] = nutrients;
        soilTests[date]["temperature"] = temperature;
        soilTests[date]["water"] = water;
    }

    void displaySoilTests() const
    {
        std::cout << "\n--- Soil Testing History ---\n";
        for (const auto& test : soilTests) {
            std::cout << "Date: " << test.first
                      << ", Fertility: " << test.second.at("fertility")
                      << ", Nutrients: " << test.second.at("nutrients")
                      << ", Temperature: " << test.second.at("temperature")
                      << ", Water: " << test.second.at("water") << "\n";
        }
    }

    // New function: Find soil test result by date
    std::map<std::string, double> findSoilTestByDate(const std::string& date) const
    {
        auto it = soilTests.find(date);
        if (it != soilTests.end())
        {
            return it->second;
        }
        return {}; // Return an empty map if the date is not found
    }

    // New function: Remove a soil test result by date
    bool removeSoilTestByDate(const std::string& date)
    {
        return soilTests.erase(date) > 0;
    }

    // New function: Update a soil test result for a specific date
    bool updateSoilTestResult(const std::string& date, double fertility, double nutrients, double temperature, double water)
    {
        auto it = soilTests.find(date);
        if (it != soilTests.end()) {
            soilTests[date]["fertility"] = fertility;
            soilTests[date]["nutrients"] = nutrients;
            soilTests[date]["temperature"] = temperature;
            soilTests[date]["water"] = water;
            return true;
        }
        return false;
    }

    // New function: Display soil test result for a specific date
    void displaySoilTestForDate(const std::string& date) const
    {
        auto it = soilTests.find(date);
        if (it != soilTests.end())
        {
            std::cout << "Date: " << date
                      << ", Fertility: " << it->second.at("fertility")
                      << ", Nutrients: " << it->second.at("nutrients")
                      << ", Temperature: " << it->second.at("temperature")
                      << ", Water: " << it->second.at("water") << "\n";
        }
        else
        {
            std::cout << "No soil test results found for the date: " << date << "\n";
        }
    }

    // New function: Display summary statistics for all soil tests
    void displaySummaryStatistics() const
    {
        if (soilTests.empty())
        {
            std::cout << "No soil tests available.\n";
            return;
        }

        double totalFertility = 0, totalNutrients = 0, totalTemperature = 0, totalWater = 0;
        int count = 0;

        for (const auto& test : soilTests)
        {
            totalFertility += test.second.at("fertility");
            totalNutrients += test.second.at("nutrients");
            totalTemperature += test.second.at("temperature");
            totalWater += test.second.at("water");
            count++;
        }

        std::cout << "\n--- Soil Testing Summary Statistics ---\n";
        std::cout << "Average Fertility: " << (totalFertility / count) << "\n";
        std::cout << "Average Nutrients: " << (totalNutrients / count) << "\n";
        std::cout << "Average Temperature: " << (totalTemperature / count) << "\n";
        std::cout << "Average Water: " << (totalWater / count) << "\n";
    }

    // New function: Check if any soil test results exist for a given date range
    bool soilTestExists(const std::string& startDate, const std::string& endDate) const
    {
        for (const auto& test : soilTests)
        {
            if (test.first >= startDate && test.first <= endDate) {
                return true;
            }
        }
        return false;
    }

    // New function: Display soil test results for a given date range
    void displaySoilTestsForDateRange(const std::string& startDate, const std::string& endDate) const
    {
        std::cout << "\n--- Soil Testing History from " << startDate << " to " << endDate << " ---\n";
        bool found = false;
        for (const auto& test : soilTests)
        {
            if (test.first >= startDate && test.first <= endDate) {
                std::cout << "Date: " << test.first
                          << ", Fertility: " << test.second.at("fertility")
                          << ", Nutrients: " << test.second.at("nutrients")
                          << ", Temperature: " << test.second.at("temperature")
                          << ", Water: " << test.second.at("water") << "\n";
                found = true;
            }
        }
        if (!found)
        {
            std::cout << "No soil test results found for the given date range.\n";
        }
    }
};

// Function to plan and track irrigation schedules
class IrrigationSchedule
{
private:
    std::map<std::string, std::string> irrigationSchedules;

public:
    void addIrrigationSchedule(const std::string& date, const std::string& schedule)
    {
        irrigationSchedules[date] = schedule;
    }

    void displayIrrigationSchedules() const
    {
        std::cout << "\n--- Irrigation Schedules ---\n";
        for (const auto& schedule : irrigationSchedules)
        {
            std::cout << "Date: " << schedule.first << ", Schedule: " << schedule.second << "\n";
        }
    }

    // New function: Find irrigation schedule by date
    std::string findIrrigationScheduleByDate(const std::string& date) const
    {
        auto it = irrigationSchedules.find(date);
        if (it != irrigationSchedules.end())
        {
            return it->second;
        }
        return "No schedule found for the given date.";
    }

    // New function: Remove an irrigation schedule by date
    bool removeIrrigationScheduleByDate(const std::string& date)
    {
        return irrigationSchedules.erase(date) > 0;
    }

    // New function: Update an irrigation schedule for a specific date
    bool updateIrrigationSchedule(const std::string& date, const std::string& newSchedule)
    {
        auto it = irrigationSchedules.find(date);
        if (it != irrigationSchedules.end())
        {
            irrigationSchedules[date] = newSchedule;
            return true;
        }
        return false;
    }

    // New function: Display irrigation schedule for a specific date
    void displayIrrigationScheduleForDate(const std::string& date) const
    {
        auto it = irrigationSchedules.find(date);
        if (it != irrigationSchedules.end()) {
            std::cout << "Date: " << date << ", Schedule: " << it->second << "\n";
        }
        else
        {
            std::cout << "No irrigation schedule found for the date: " << date << "\n";
        }
    }

    // New function: Display summary statistics for all irrigation schedules
    void displaySummaryStatistics() const
    {
        if (irrigationSchedules.empty())
        {
            std::cout << "No irrigation schedules available.\n";
            return;
        }

        std::cout << "\n--- Irrigation Schedules Summary Statistics ---\n";
        std::cout << "Total number of schedules: " << irrigationSchedules.size() << "\n";
    }

    // New function: Check if any irrigation schedules exist for a given date range
    bool irrigationScheduleExists(const std::string& startDate, const std::string& endDate) const
    {
        for (const auto& schedule : irrigationSchedules)
        {
            if (schedule.first >= startDate && schedule.first <= endDate)
            {
                return true;
            }
        }
        return false;
    }

    // New function: Display irrigation schedules for a given date range
    void displayIrrigationSchedulesForDateRange(const std::string& startDate, const std::string& endDate) const
    {
        std::cout << "\n--- Irrigation Schedules from " << startDate << " to " << endDate << " ---\n";
        bool found = false;
        for (const auto& schedule : irrigationSchedules)
        {
            if (schedule.first >= startDate && schedule.first <= endDate)
            {
                std::cout << "Date: " << schedule.first << ", Schedule: " << schedule.second << "\n";
                found = true;
            }
        }
        if (!found)
        {
            std::cout << "No irrigation schedules found for the given date range.\n";
        }
    }
};

// Function to track and manage pest control activities
class PestControlManagement
{
private:
    std::map<std::string, std::string> pestControlActivities;

public:
    void addPestControlActivity(const std::string& date, const std::string& activity)
    {
        pestControlActivities[date] = activity;
    }

    void displayPestControlActivities() const
    {
        std::cout << "\n--- Pest Control Activities ---\n";
        for (const auto& activity : pestControlActivities)
        {
            std::cout << "Date: " << activity.first << ", Activity: " << activity.second << "\n";
        }
    }

    // New function: Find pest control activity by date
    std::string findPestControlActivityByDate(const std::string& date) const
    {
        auto it = pestControlActivities.find(date);
        if (it != pestControlActivities.end())
        {
            return it->second;
        }
        return "No activity found for the given date.";
    }

    // New function: Remove a pest control activity by date
    bool removePestControlActivityByDate(const std::string& date) {
        return pestControlActivities.erase(date) > 0;
    }

    // New function: Update a pest control activity for a specific date
    bool updatePestControlActivity(const std::string& date, const std::string& newActivity)
    {
        auto it = pestControlActivities.find(date);
        if (it != pestControlActivities.end())
        {
            pestControlActivities[date] = newActivity;
            return true;
        }
        return false;
    }

    // New function: Display pest control activity for a specific date
    void displayPestControlActivityForDate(const std::string& date) const
    {
        auto it = pestControlActivities.find(date);
        if (it != pestControlActivities.end())
        {
            std::cout << "Date: " << date << ", Activity: " << it->second << "\n";
        }
        else
        {
            std::cout << "No pest control activity found for the date: " << date << "\n";
        }
    }

    // New function: Display summary statistics for all pest control activities
    void displaySummaryStatistics() const
    {
        if (pestControlActivities.empty())
        {
            std::cout << "No pest control activities available.\n";
            return;
        }

        std::cout << "\n--- Pest Control Activities Summary Statistics ---\n";
        std::cout << "Total number of activities: " << pestControlActivities.size() << "\n";
    }

    // New function: Check if any pest control activities exist for a given date range
    bool pestControlActivityExists(const std::string& startDate, const std::string& endDate) const
    {
        for (const auto& activity : pestControlActivities)
        {
            if (activity.first >= startDate && activity.first <= endDate)
            {
                return true;
            }
        }
        return false;
    }

    // New function: Display pest control activities for a given date range
    void displayPestControlActivitiesForDateRange(const std::string& startDate, const std::string& endDate) const
    {
        std::cout << "\n--- Pest Control Activities from " << startDate << " to " << endDate << " ---\n";
        bool found = false;
        for (const auto& activity : pestControlActivities)
        {
            if (activity.first >= startDate && activity.first <= endDate)
            {
                std::cout << "Date: " << activity.first << ", Activity: " << activity.second << "\n";
                found = true;
            }
        }
        if (!found)
        {
            std::cout << "No pest control activities found for the given date range.\n";
        }
    }
};

// Function to predict crop yields based on various factors
class YieldPrediction
{
public:
    // Predict yield based on various factors
    double predictYield(double soilFertility, double nutrientLevels, double temperature, double waterAvailability, double acreage) const
    {
        // Simple formula for prediction, can be replaced with a more complex model
        return (soilFertility * 0.3 + nutrientLevels * 0.3 + temperature * 0.2 + waterAvailability * 0.2) * acreage;
    }

    // Display prediction information
    void displayPrediction(double soilFertility, double nutrientLevels, double temperature, double waterAvailability, double acreage) const
    {
        double predictedYield = predictYield(soilFertility, nutrientLevels, temperature, waterAvailability, acreage);
        std::cout << "\n--- Yield Prediction ---\n";
        std::cout << "Soil Fertility: " << soilFertility << "\n";
        std::cout << "Nutrient Levels: " << nutrientLevels << "\n";
        std::cout << "Temperature: " << temperature << " C\n";
        std::cout << "Water Availability: " << waterAvailability << "\n";
        std::cout << "Acreage: " << acreage << " acres\n";
        std::cout << "Predicted Yield: " << predictedYield << " units\n";
    }

    // Validate input parameters for yield prediction
    bool validateInputs(double soilFertility, double nutrientLevels, double temperature, double waterAvailability, double acreage) const
    {
        if (soilFertility < 0 || soilFertility > 100)
        {
            std::cout << "Error: Soil fertility must be between 0 and 100.\n";
            return false;
        }
        if (nutrientLevels < 0 || nutrientLevels > 100)
        {
            std::cout << "Error: Nutrient levels must be between 0 and 100.\n";
            return false;
        }
        if (temperature < -50 || temperature > 50)
        {
            std::cout << "Error: Temperature must be between -50 and 50 C.\n";
            return false;
        }
        if (waterAvailability < 0 || waterAvailability > 100)
        {
            std::cout << "Error: Water availability must be between 0 and 100.\n";
            return false;
        }
        if (acreage <= 0)
        {
            std::cout << "Error: Acreage must be greater than 0.\n";
            return false;
        }
        return true;
    }

    // Get user input for yield prediction
    void getUserInputAndPredict()
    {
        double soilFertility, nutrientLevels, temperature, waterAvailability, acreage;
        std::cout << "Enter soil fertility level (0-100): ";
        std::cin >> soilFertility;
        std::cout << "Enter nutrient levels (0-100): ";
        std::cin >> nutrientLevels;
        std::cout << "Enter temperature (in Celsius): ";
        std::cin >> temperature;
        std::cout << "Enter water availability (0-100): ";
        std::cin >> waterAvailability;
        std::cout << "Enter acreage: ";
        std::cin >> acreage;

        if (validateInputs(soilFertility, nutrientLevels, temperature, waterAvailability, acreage)) {
            displayPrediction(soilFertility, nutrientLevels, temperature, waterAvailability, acreage);
        }
    }
};

// Crop Monitoring class
class CropMonitoring
{
public:
    void monitorCropHealth()
    {
        std::cout << "Monitoring crop health using IoT devices and drones...\n";
        // Allow user to input crop health status
        int healthStatus;
        std::cout << "Enter crop health status (1-100): ";
        std::cin >> healthStatus;

        if (healthStatus > 80)
        {
            std::cout << "Crop health is excellent.\n";
        }
        else if (healthStatus > 50)
        {
            std::cout << "Crop health is average. Consider taking preventive measures.\n";
        }
        else
        {
            std::cout << "Crop health is poor. Immediate action required.\n";
        }
    }

    void monitorGrowth()
    {
        std::cout << "Monitoring crop growth...\n";
        // Allow user to input growth stage
        int growthStage;
        std::cout << "Enter crop growth stage (1-5): ";
        std::cin >> growthStage;
        std::cout << "Current growth stage: " << growthStage << " out of 5.\n";
    }

    // New function: Record environmental conditions
    void recordEnvironmentalConditions()
    {
        double temperature, humidity, rainfall;
        std::cout << "Enter current temperature (C): ";
        std::cin >> temperature;
        std::cout << "Enter current humidity (%): ";
        std::cin >> humidity;
        std::cout << "Enter recent rainfall (mm): ";
        std::cin >> rainfall;

        std::cout << "\n--- Environmental Conditions ---\n";
        std::cout << "Temperature: " << temperature << " C\n";
        std::cout << "Humidity: " << humidity << " %\n";
        std::cout << "Rainfall: " << rainfall << " mm\n";
    }

    // New function: Analyze soil quality
    void analyzeSoilQuality()
    {
        double pH, nitrogen, phosphorus, potassium;
        std::cout << "Enter soil pH level: ";
        std::cin >> pH;
        std::cout << "Enter soil nitrogen content (mg/kg): ";
        std::cin >> nitrogen;
        std::cout << "Enter soil phosphorus content (mg/kg): ";
        std::cin >> phosphorus;
        std::cout << "Enter soil potassium content (mg/kg): ";
        std::cin >> potassium;

        std::cout << "\n--- Soil Quality Analysis ---\n";
        std::cout << "pH Level: " << pH << "\n";
        std::cout << "Nitrogen: " << nitrogen << " mg/kg\n";
        std::cout << "Phosphorus: " << phosphorus << " mg/kg\n";
        std::cout << "Potassium: " << potassium << " mg/kg\n";
    }

    // New function: Suggest crop improvements
    void suggestCropImprovements() const
    {
        std::cout << "\n--- Crop Improvement Suggestions ---\n";
        std::cout << "1. Ensure proper irrigation and drainage.\n";
        std::cout << "2. Use organic compost to improve soil fertility.\n";
        std::cout << "3. Implement integrated pest management.\n";
        std::cout << "4. Rotate crops to prevent soil depletion.\n";
        std::cout << "5. Monitor and manage nutrient levels regularly.\n";
    }
};

// Labor and Equipment Management class
class LaborAndEquipmentManagement
{
private:
    std::map<std::string, int> laborAllocation;
    std::map<std::string, int> equipmentAllocation;

public:
    void allocateResources(const std::string& activity, int labor, int equipment)
    {
        laborAllocation[activity] += labor;
        equipmentAllocation[activity] += equipment;
        std::cout << "Allocated " << labor << " workers and " << equipment << " equipment units for " << activity << ".\n";
    }

    void displayAllocations() const
    {
        std::cout << "Current labor and equipment allocations:\n";
        for (const auto& pair : laborAllocation)
        {
            std::cout << "- " << pair.first << ": " << pair.second << " workers, "
                      << equipmentAllocation.at(pair.first) << " equipment units.\n";
        }
    }

    // New function: Deallocate resources
    void deallocateResources(const std::string& activity, int labor, int equipment)
    {
        if (laborAllocation.find(activity) != laborAllocation.end())
        {
            laborAllocation[activity] = std::max(0, laborAllocation[activity] - labor);
            equipmentAllocation[activity] = std::max(0, equipmentAllocation[activity] - equipment);
            std::cout << "Deallocated " << labor << " workers and " << equipment << " equipment units from " << activity << ".\n";
        }
        else
        {
            std::cout << "No resources allocated for " << activity << ".\n";
        }
    }

    // New function: Display total allocations
    void displayTotalAllocations() const
    {
        int totalLabor = 0;
        int totalEquipment = 0;
        for (const auto& pair : laborAllocation)
        {
            totalLabor += pair.second;
            totalEquipment += equipmentAllocation.at(pair.first);
        }
        std::cout << "Total allocated resources: " << totalLabor << " workers, " << totalEquipment << " equipment units.\n";
    }

    // New function: Reset allocations for a specific activity
    void resetAllocations(const std::string& activity)
    {
        laborAllocation[activity] = 0;
        equipmentAllocation[activity] = 0;
        std::cout << "Reset allocations for " << activity << ".\n";
    }

    // New function: Check if resources are allocated for a specific activity
    bool isAllocated(const std::string& activity) const
    {
        return laborAllocation.find(activity) != laborAllocation.end() && laborAllocation.at(activity) > 0;
    }
};

// Emergency Preparedness class
class EmergencyPreparedness
{
private:
    std::map<std::string, std::vector<std::string>> resources;

public:
    // Respond to weather change with appropriate action
    void respondToWeatherChange(const std::string& weatherEvent)
    {
        std::cout << "Emergency response activated for: " << weatherEvent << "\n";
        if (weatherEvent == "storm")
        {
            std::cout << "Securing crops with protective covers.\n";
        }
        else if (weatherEvent == "frost")
        {
            std::cout << "Activating frost heaters.\n";
        }
        else if (weatherEvent == "flood")
        {
            std::cout << "Diverting water and protecting crops.\n";
        }
        else
        {
            std::cout << "Taking general precautions.\n";
        }
    }

    // New function: Add resources for emergency preparedness
    void addResource(const std::string& resource, const std::string& weatherEvent)
    {
        resources[weatherEvent].push_back(resource);
        std::cout << "Added resource \"" << resource << "\" for weather event \"" << weatherEvent << "\".\n";
    }

    // New function: Display resources for a specific weather event
    void displayResourcesForEvent(const std::string& weatherEvent) const
    {
        auto it = resources.find(weatherEvent);
        if (it != resources.end())
        {
            std::cout << "Resources for " << weatherEvent << ":\n";
            for (const auto& resource : it->second)
            {
                std::cout << "- " << resource << "\n";
            }
        }
        else
        {
            std::cout << "No resources found for " << weatherEvent << ".\n";
        }
    }

    // New function: Display all resources
    void displayAllResources() const
    {
        std::cout << "\n--- All Emergency Resources ---\n";
        for (const auto& pair : resources)
        {
            std::cout << "Weather Event: " << pair.first << "\n";
            for (const auto& resource : pair.second)
            {
                std::cout << "- " << resource << "\n";
            }
        }
    }

    // New function: Remove a resource for a specific weather event
    void removeResource(const std::string& resource, const std::string& weatherEvent)
    {
        auto it = resources.find(weatherEvent);
        if (it != resources.end())
        {
            auto& vec = it->second;
            vec.erase(std::remove(vec.begin(), vec.end(), resource), vec.end());
            std::cout << "Removed resource \"" << resource << "\" for weather event \"" << weatherEvent << "\".\n";
        }
        else
        {
            std::cout << "No resources found for " << weatherEvent << ".\n";
        }
    }
};

// Sustainability and Carbon Footprint Reduction class
class Sustainability
{
private:
    std::map<std::string, std::vector<std::string>> implementedPractices;

public:
    // Implement practice to reduce emissions
    void reduceEmissions(const std::string& practice)
    {
        std::cout << "Implementing practice to reduce emissions: " << practice << "\n";
        if (practice == "no-till farming")
        {
            std::cout << "Reducing soil disturbance to lower carbon emissions.\n";
        }
        else if (practice == "cover crops")
        {
            std::cout << "Improving soil health and carbon sequestration.\n";
        }
        else if (practice == "renewable energy")
        {
            std::cout << "Using solar and wind energy for farming operations.\n";
        }
        else
        {
            std::cout << "Adopting general sustainable practices.\n";
        }
        // Add the practice to the list of implemented practices
        implementedPractices["emission reduction"].push_back(practice);
    }

    // New function: Add a new sustainability practice
    void addPractice(const std::string& category, const std::string& practice)
    {
        implementedPractices[category].push_back(practice);
        std::cout << "Added practice \"" << practice << "\" under category \"" << category << "\".\n";
    }

    // New function: Display all implemented practices
    void displayPractices() const
    {
        std::cout << "\n--- Implemented Sustainability Practices ---\n";
        for (const auto& pair : implementedPractices)
        {
            std::cout << "Category: " << pair.first << "\n";
            for (const auto& practice : pair.second)
            {
                std::cout << "- " << practice << "\n";
            }
        }
    }

    // New function: Display practices for a specific category
    void displayPracticesByCategory(const std::string& category) const
    {
        auto it = implementedPractices.find(category);
        if (it != implementedPractices.end())
        {
            std::cout << "\nPractices under category \"" << category << "\":\n";
            for (const auto& practice : it->second) {
                std::cout << "- " << practice << "\n";
            }
        }
        else
        {
            std::cout << "No practices found for category \"" << category << "\".\n";
        }
    }

    // New function: Remove a practice from a specific category
    void removePractice(const std::string& category, const std::string& practice)
    {
        auto it = implementedPractices.find(category);
        if (it != implementedPractices.end())
        {
            auto& practices = it->second;
            auto practiceIt = std::remove(practices.begin(), practices.end(), practice);
            if (practiceIt != practices.end())
            {
                practices.erase(practiceIt, practices.end());
                std::cout << "Removed practice \"" << practice << "\" from category \"" << category << "\".\n";
            }
            else
            {
                std::cout << "Practice \"" << practice << "\" not found in category \"" << category << "\".\n";
            }
        }
        else
        {
            std::cout << "No practices found for category \"" << category << "\".\n";
        }
    }
};


#include <iostream>
#include <vector>
#include <queue>
#include <cmath>

using namespace std;

// --- Weather-Based Yield Prediction --- //
// Linear Regression for Yield Prediction

struct WeatherData
{
    double temperature;
    double rainfall;
    double sunlight;
};


double predictYield(const vector<WeatherData>& data, const WeatherData& current)
{

    // Example coefficients for simplicity
    double tempCoeff = 0.5, rainCoeff = 0.3, sunCoeff = 0.2;

    return tempCoeff * current.temperature +
           rainCoeff * current.rainfall +
           sunCoeff * current.sunlight;
}


void simulateWeatherData(vector<WeatherData>& data, int size)
{
    srand(time(0)); // Seed for random number generation

    for (int i = 0; i < size; i++)
    {
        double temperature = 20 + static_cast<double>(rand()) / RAND_MAX * (35 - 20);

        double rainfall = 50 + static_cast<double>(rand()) / RAND_MAX * (150 - 50);

        double sunlight = 5 + static_cast<double>(rand()) / RAND_MAX * (12 - 5);

        data.push_back({temperature, rainfall, sunlight});

    }
}

// --- Pollution Impact Analysis --- //
// Graph Representation for Urban Pollution Impact
const int MAX_CROPS = 20;

vector<pair<string, double>> adj[MAX_CROPS]; // adjacency list with pollution levels


vector<string> cropNames = {
    "Tomatoes",
    "Spinach",
    "Lettuce",
    "Carrots",
    "Peppers",
    "Cucumbers",
    "Eggplants",
    "Basil",
    "Mint",
    "Parsley",
    "Kale",
    "Broccoli",
    "Cauliflower",
    "Zucchini",
    "Strawberries",
    "Beans",
    "Peas",
    "Chard",
    "Coriander",
    "Thyme",
    "Radishes",
    "Squash",
    "Pumpkin",
    "Sweetcorn",
    "Cabbage",
    "Onions",
    "Garlic",

};


void addPollutionEdge(int u, int v, double pollutionLevel)
{

    adj[u].push_back({cropNames[v], pollutionLevel});

    adj[v].push_back({cropNames[u], pollutionLevel});

}
void AlgoFunction() {
    std::cout << "!" << std::endl;
}



void analyzePollutionImpact(int startNode, vector<double>& pollutionLevels)
{

    vector<bool> visited(MAX_CROPS, false);

    queue<int> q;

    q.push(startNode);

    visited[startNode] = true;


    while (!q.empty())
    {
        int node = q.front();

        q.pop();

        for (auto& neighbor : adj[node])
        {

            int nextNode = &neighbor - &adj[node][0];

            double pollution = neighbor.second;


            if (!visited[nextNode])
            {

                pollutionLevels[nextNode] += pollution;

                visited[nextNode] = true;

                q.push(nextNode);

            }
        }
    }
}


void simulatePollutionGraph(int nodes, int edges)
{
    srand(time(0));


    for (int i = 0; i < edges; i++)
    {

        int u = rand() % nodes;

        int v = rand() % nodes;

        double pollution = 5 + static_cast<double>(rand()) / RAND_MAX * (50 - 5);

        addPollutionEdge(u, v, pollution);

    }
}


// --- Urban Beekeeping Logistics --- //
// Dijkstra's Algorithm for Optimal Path
struct Edge3
{

    int to;

    double weight;

};


vector<Edge3> graph[MAX_CROPS];

void addLogisticsEdge(int u, int v, double weight)
{

    graph[u].push_back({v, weight});

    graph[v].push_back({u, weight});

}


vector<double> dijkstra(int source, int n)
{
    vector<double> dist(n, 1e9); // Use a large value to represent infinity

    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq;

    dist[source] = 0;

    pq.push({0, source});

    while (!pq.empty()) {
        auto [currentDist, currentNode] = pq.top();

        pq.pop();

        if (currentDist > dist[currentNode]) continue;


        for (const auto& edge3 : graph[currentNode])
        {
            int nextNode = edge3.to;

            double weight = edge3.weight;


            if (dist[currentNode] + weight < dist[nextNode])
            {

                dist[nextNode] = dist[currentNode] + weight;

                pq.push({dist[nextNode], nextNode});
            }
        }
    }

    return dist;
}


enum BeeProducts { HONEYs, WAXs, ROYAL_JELLYs, POLLENs, BEE_PRODUCT_COUNTs};

vector<string> beeProductss = {"Honeys", "Waxs", "Royal Jellys", "Pollens"};

void handleBeeProducts(int productsID) {
    switch (productsID) {
        case HONEYs:
            cout << "Product: Honey\nUsage: Food, medicine.\n";
            break;
        case WAXs:
            cout << "Product: Wax\nUsage: Candles, polish.\n";
            break;
        case ROYAL_JELLYs:
            cout << "Product: Royal Jelly\nUsage: Health supplement.\n";
            break;
        case POLLENs:
            cout << "Product: Pollen\nUsage: Food additive.\n";
            break;
        default:
            cout << "Invalid product.\n";
    }
}


void simulateLogisticsGraph(int nodes, int edges3)
{
    srand(time(0));


    for (int i = 0; i < edges3; i++)
    {

        int u = rand() % nodes;
        int v = rand() % nodes;
        double weight = 1 + static_cast<double>(rand()) / RAND_MAX * (20 - 1);

        addLogisticsEdge(u, v, weight);
    }
}


// --- Additional Functions for Farm Logistics --- //
// Place Descriptions and Harvest Costs
struct Place
{
    string name;
    double distance;
    double supplyCostPerKm;
};


void describePlaces(const vector<Place>& places)
{
    // Displaying the places
    for (const auto& place : places)
    {
        cout << "Place: " << place.name << ", Distance: " << place.distance << " km, Cost/Km: " << place.supplyCostPerKm << " units" << endl;
    }
}


enum WeatherAlertType { FLOOD, DROUGHT, FROST, STORM, WEATHER_ALERT_COUNT };

vector<string> weatherAlerts = {"Flood", "Drought", "Frost", "Storm"};

void handleWeatherAlert(int alertID) {
    switch (alertID) {
        case FLOOD:
            cout << "Alert: Flood\nPrecautions: Evacuate low-lying areas immediately.\n";
            break;
        case DROUGHT:
            cout << "Alert: Drought\nPrecautions: Conserve water and irrigate wisely.\n";
            break;
        case FROST:
            cout << "Alert: Frost\nPrecautions: Cover crops to protect them.\n";
            break;
        case STORM:
            cout << "Alert: Storm\nPrecautions: Secure loose items and stay indoors.\n";
            break;
        default:
            cout << "Invalid weather alert.\n";
    }
}

enum YieldYear { YEAR_2021, YEAR_2022, YEAR_2023, YEAR_2024, YEAR_COUNT };

vector<string> yieldYears = {"2021", "2022", "2023", "2024"};

void handleYieldHistory(int yearID) {
    switch (yearID) {
        case YEAR_2021:
            cout << "Year: 2021\nCrop: Tomatoes\nYield: 12 tons.\n";
            break;
        case YEAR_2022:
            cout << "Year: 2022\nCrop: Spinach\nYield: 10 tons.\n";
            break;
        case YEAR_2023:
            cout << "Year: 2023\nCrop: Lettuce\nYield: 15 tons.\n";
            break;
        case YEAR_2024:
            cout << "Year: 2024\nCrop: Carrots\nYield: 18 tons.\n";
            break;
        default:
            cout << "Invalid year.\n";
    }
}


enum IrrigationType { DRIP, SPRINKLER, FURROW, IRRIGATION_COUNT };

vector<string> irrigationMethods = {"Drip", "Sprinkler", "Furrow"};

void handleIrrigation(int irrigationID) {
    switch (irrigationID) {
        case DRIP:
            cout << "Irrigation: Drip\nEfficiency: 90%.\nSuitable for: Vegetables.\n";
            break;
        case SPRINKLER:
            cout << "Irrigation: Sprinkler\nEfficiency: 70%.\nSuitable for: Large fields.\n";
            break;
        case FURROW:
            cout << "Irrigation: Furrow\nEfficiency: 50%.\nSuitable for: Orchards.\n";
            break;
        default:
            cout << "Invalid irrigation method.\n";
    }
}


double calculateTotalSupplyCost(const vector<Place>& places, double yieldAmount)
{
    double totalCost = 0;
    for (const auto& place : places)
    {
        totalCost += place.distance * place.supplyCostPerKm * yieldAmount;
    }
    return totalCost;
}


// Suggest the best option based on cost and distance
void suggestBestOption(const vector<Place>& places, double yieldAmount)
{

    double minCost = 1e9;
    string bestPlace;

    for (const auto& place : places)
    {
        double cost = place.distance * place.supplyCostPerKm * yieldAmount;
        if (cost < minCost)
        {
            minCost = cost;
            bestPlace = place.name;
        }
    }

    cout << "\nBest Option: " << bestPlace << " with a total cost of " << minCost << " units." << endl;
}


// Yield Improvement Suggestions
void showSoilImprovementMenu()
{
    cout << "\n--- Yield Improvement Suggestions ---" << endl;

    cout << "1. Rotate Crops to Preserve Soil Nutrients" << endl;

    cout << "2. Use Organic Fertilizers" << endl;

    cout << "3. Test and Balance Soil pH Levels" << endl;

    cout << "4. Implement Mulching to Retain Moisture" << endl;

    cout << "5. Adopt Cover Crops for Soil Protection" << endl;

    cout << "6. Apply Compost for Improved Soil Structure" << endl;

    cout << "7. Manage Irrigation to Prevent Overwatering" << endl;

    cout << "8. Use Biochar to Enhance Soil Quality" << endl;

    cout << "9. Reduce Soil Compaction through Controlled Traffic" << endl;

    cout << "10. Implement Integrated Pest Management (IPM)" << endl;

    cout << "11. Use Raised Beds for Better Drainage and Soil Control" << endl;

    cout << "12. Utilize Vertical Gardens for Space Efficiency" << endl;

    cout << "13. Integrate Aquaponics Systems for Nutrient Cycling" << endl;

    cout << "14. Recycle Kitchen Waste into Compost or Vermicompost" << endl;

    cout << "15. Use Rainwater Harvesting to Supplement Irrigation" << endl;

    cout << "16. Install Drip Irrigation to Conserve Water" << endl;

    cout << "17. Introduce Companion Planting for Pest Control" << endl;

    cout << "18. Incorporate Native Plants to Promote Biodiversity" << endl;

    cout << "19. Grow Nitrogen-Fixing Plants to Enrich the Soil" << endl;

    cout << "20. Use Green Manure to Add Nutrients to the Soil" << endl;

    cout << "21. Grow Mushrooms in Urban Spaces for Waste Recycling" << endl;

    cout << "22. Use Biofertilizers for Soil Health" << endl;

    cout << "23. Build Soil Bioactivity by Using Worms for Vermiculture" << endl;

    cout << "24. Choose Drought-Resistant Crops for Water Conservation" << endl;

    cout << "25. Implement Permaculture Principles for Long-Term Soil Health" << endl;


    cout << "26. Exit Suggestions Menu" << endl;

    cout << "Choose an option: ";
}

void displaySoilImprovementSuggestions()
{
    int choice;

    do {
        showSoilImprovementMenu();
        cin >> choice;

        switch (choice)
        {
            case 1:
                cout << "1. Rotate Crops to Preserve Soil Nutrients\n";
                cout << "2. Alternate legumes with cereals to replenish nitrogen in the soil.\n";
                cout << "3. Use cover crops like clover during fallow seasons.\n";
                cout << "4. Avoid planting the same crop family in consecutive cycles.\n";
                cout << "5. Rotate deep-rooted crops with shallow-rooted ones.\n";
                break;
            case 2:
                cout << "1. Use well-rotted manure to improve soil structure.\n";
                cout << "2. Incorporate green manure crops into the soil.\n";
                cout << "3. Apply compost teas for targeted nutrient delivery.\n";
                cout << "4. Use bio-fertilizers to promote beneficial microorganisms.\n";
                break;
            case 3:
                cout << "1. Conduct a soil test at least once a year.\n";
                cout << "2. Add agricultural lime to increase soil pH if acidic.\n";
                cout << "3. Use sulfur to reduce soil pH if alkaline.\n";
                cout << "4. Incorporate organic matter to stabilize pH levels.\n";
                break;
            case 4:
                cout << "1. Use straw or wood chips for mulching.\n";
                cout << "2. Avoid plastic mulch in high temperatures.\n";
                cout << "3. Ensure the mulch layer is at least 2-3 inches thick.\n";
                cout << "4. Apply mulch around the base of plants to retain moisture.\n";
                break;
            case 5:
                cout << "1. Plant cover crops like rye, vetch, or clover in offseason.\n";
                cout << "2. Mow cover crops before they go to seed.\n";
                cout << "3. Choose cover crops suited to your soil type and climate.\n";
                cout << "4. Incorporate cover crops into the soil to add organic matter.\n";
                break;
            case 6:
                cout << "1. Mix compost with topsoil for better integration.\n";
                cout << "2. Use vermicompost for high-nutrient content.\n";
                cout << "3. Apply compost in late fall or early spring.\n";
                cout << "4. Avoid overloading the soil with fresh compost.\n";
                break;
            case 7:
                cout << "1. Use drip irrigation for efficient water delivery.\n";
                cout << "2. Water early in the morning to reduce evaporation.\n";
                cout << "3. Check soil moisture before irrigation.\n";
                cout << "4. Avoid watering during heavy rains to prevent waterlogging.\n";
                break;
            case 8:
                cout << "1. Apply biochar in combination with compost.\n";
                cout << "2. Use biochar in sandy soils to improve water retention.\n";
                cout << "3. Test biochar for pH neutrality before applying.\n";
                cout << "4. Incorporate biochar during soil tilling.\n";
                break;
            case 9:
                cout << "1. Restrict heavy machinery to specific paths.\n";
                cout << "2. Use lightweight equipment to reduce compaction.\n";
                cout << "3. Rotate fields to distribute machinery traffic.\n";
                cout << "4. Aerate compacted soil regularly.\n";
                break;
            case 10:
                cout << "1. Introduce beneficial insects like ladybugs.\n";
                cout << "2. Use pheromone traps to monitor pests.\n";
                cout << "3. Avoid overusing chemical pesticides.\n";
                cout << "4. Grow pest-repelling plants such as marigolds.\n";
                break;
            case 11:
                cout << "1. Use Raised Beds for Better Drainage and Soil Control\n";
                cout << "2. Use soil mixes in raised beds for optimal drainage.\n";
                cout << "3. Rotate plants in raised beds to prevent nutrient depletion.\n";
                cout << "4. Ensure raised beds are adequately irrigated.\n";
                break;
            case 12:
                cout << "1. Utilize Vertical Gardens for Space Efficiency\n";
                cout << "2. Choose plants that thrive in vertical spaces.\n";
                cout << "3. Use containers or trellises to support climbing plants.\n";
                cout << "4. Rotate crops in vertical gardens to avoid soil depletion.\n";
                break;
            case 13:
                cout << "1. Integrate Aquaponics Systems for Nutrient Cycling\n";
                cout << "2. Use fish waste as a natural fertilizer for plants.\n";
                cout << "3. Ensure proper water circulation in the aquaponics system.\n";
                cout << "4. Monitor nutrient levels for optimal plant growth.\n";
                break;
            case 14:
                cout << "1. Recycle Kitchen Waste into Compost or Vermicompost\n";
                cout << "2. Use fruit and vegetable scraps to create nutrient-rich compost.\n";
                cout << "3. Add egg shells and coffee grounds for additional nutrients.\n";
                cout << "4. Avoid adding meat or dairy to compost piles.\n";
                break;
            case 15:
                cout << "1. Use Rainwater Harvesting to Supplement Irrigation\n";
                cout << "2. Install rainwater collection systems on rooftops.\n";
                cout << "3. Use collected rainwater to reduce reliance on municipal water.\n";
                cout << "4. Regularly clean gutters and storage containers for safety.\n";
                break;
            case 16:
                cout << "1. Install Drip Irrigation to Conserve Water\n";
                cout << "2. Set up a timer for drip systems to minimize water waste.\n";
                cout << "3. Use a pressure regulator for uniform water distribution.\n";
                cout << "4. Ensure that the water is delivered directly to the plant roots.\n";
                break;
            case 17:
                cout << "1. Introduce Companion Planting for Pest Control\n";
                cout << "2. Pair marigolds with tomatoes to repel pests.\n";
                cout << "3. Plant basil near peppers to enhance growth and flavor.\n";
                cout << "4. Avoid planting incompatible plants near each other.\n";
                break;
            case 18:
                cout << "1. Incorporate Native Plants to Promote Biodiversity\n";
                cout << "2. Choose drought-tolerant native species for water conservation.\n";
                cout << "3. Attract pollinators by planting native flowers.\n";
                cout << "4. Use native grasses to prevent soil erosion.\n";
                break;
            case 19:
                cout << "1. Grow Nitrogen-Fixing Plants to Enrich the Soil\n";
                cout << "2. Plant legumes like peas and beans to improve nitrogen content.\n";
                cout << "3. Rotate legumes with other crops to maintain soil fertility.\n";
                cout << "4. Incorporate leguminous cover crops into the soil for enrichment.\n";
                break;
            case 20:
                cout << "1. Use Green Manure to Add Nutrients to the Soil\n";
                cout << "2. Grow buckwheat or clover as green manure.\n";
                cout << "3. Incorporate green manure crops into the soil during fallow periods.\n";
                cout << "4. Ensure green manure is tilled into the soil before it goes to seed.\n";
                break;
            case 21:
                cout << "1. Grow Mushrooms in Urban Spaces for Waste Recycling\n";
                cout << "2. Use organic waste as a substrate for mushroom cultivation.\n";
                cout << "3. Ensure proper ventilation and humidity for mushroom growth.\n";
                cout << "4. Harvest mushrooms at the right stage for maximum yield.\n";
                break;
            case 22:
                cout << "1. Use Biofertilizers for Soil Health\n";
                cout << "2. Apply mycorrhizal fungi to promote root health.\n";
                cout << "3. Introduce beneficial bacteria to enhance nutrient uptake.\n";
                cout << "4. Use liquid biofertilizers for quick absorption.\n";
                break;
            case 23:
                cout << "1. Build Soil Bioactivity by Using Worms for Vermiculture\n";
                cout << "2. Create worm bins to compost organic waste.\n";
                cout << "3. Use vermicompost to improve soil structure and fertility.\n";
                cout << "4. Ensure worms are well-fed and have proper drainage.\n";
                break;
            case 24:
                cout << "1. Choose Drought-Resistant Crops for Water Conservation\n";
                cout << "2. Plant drought-tolerant varieties of vegetables and herbs.\n";
                cout << "3. Use soil amendments like compost to improve water retention.\n";
                cout << "4. Ensure crops are watered deeply to encourage deep root growth.\n";
                break;
            case 25:
                cout << "1. Implement Permaculture Principles for Long-Term Soil Health\n";
                cout << "2. Design your garden to mimic natural ecosystems.\n";
                cout << "3. Use mulching, composting, and crop rotation in permaculture.\n";
                cout << "4. Plan for minimal soil disturbance in permaculture gardens.\n";
                break;

        }
    } while (choice != 0);
}

// --- Menu System --- //
void showMainMenu()
{

    cout << "\n--- Farm Management System ---" << endl;

    cout << "1. Choose Type of Crop Grown" << endl;

    cout << "2. Weather-Based Yield Prediction" << endl;

    cout << "3. Pollution Impact Analysis" << endl;


    cout << "4. Urban Beekeeping Logistics" << endl;


    cout << "5. Places Around the Farm and Supply Cost" << endl;

    cout << "6. Soil Improvement Suggestions" << endl;

    cout << "7. Exit" << endl;

    cout << "Choose an option: ";
}

void placeholderFunction1() {
    cout << "Placeholder Function 1 is called.\n";
}

void placeholderFunction2() {
    cout << "Placeholder Function 2 is called.\n";
}


void showCropMenu()
{
    cout << "\n--- Select Crop Type ---" << endl;
    for (int i = 0; i < cropNames.size(); i++)
    {
        cout << i + 1 << ". " << cropNames[i] << endl;
    }
    cout << "Choose a crop: ";
}


void showYieldMenu()
{
    cout << "\n--- Enter Yield Amount ---" << endl;
    cout << "Enter the amount of yield (in tons): ";
}
int algorithm_function(const vector<int>& algorithm_input) {
    /*
     * This is a placeholder algorithm function.
     * It performs various operations but does not alter the main program's functionality.
     */

    // Initialize an algorithm-specific variable
    int result = 0;

    // Example of a loop
    for (int i = 0; i < 10; i++) {
        // Perform an algorithm-like calculation
        result += i * 2;

        // Add a conditional for demonstration purposes
        if (result % 5 == 0) {
            result -= 1;
        } else {
            result += 1;
        }
    }

    // Example of working with algorithm input
    result += algorithm_input.size();

    // Print the algorithm result (optional)
    cout << "Algorithm result from algorithm_function: " << result << endl;

    // Return a meaningless value
    return result * 2; // Just doubling the result for no real reason
}

// --- Crop Rotation Planning --- //
struct CropRotation
{
    string cropName;
    int duration; // Duration in years
    string benefits;
};

vector<CropRotation> cropRotations = {
    {"Tomatoes", 2, "Improves soil nutrients and reduces pests."},
    {"Spinach", 1, "Enhances soil structure and provides quick yield."},
    // Add more crops and their rotation details
};

void displayCropRotations() {
    cout << "\n--- Crop Rotation Suggestions ---" << endl;
    for (const auto& rotation : cropRotations) {
        cout << "Crop: " << rotation.cropName
             << ", Duration: " << rotation.duration
             << " years, Benefits: " << rotation.benefits << endl;
    }
}


enum Fertilizers { UREAs, DAPs, MOPs, FERTILIZER_COUNTs };

vector<string> fertilizerss = {"Ureas", "DAPs", "MOPs"};

void handleFertilizers(int fertilizersID) {
    switch (fertilizersID) {
        case UREAs:
            cout << "Fertilizer: Urea\nUsage: Increases nitrogen levels.\n";
            break;
        case DAPs:
            cout << "Fertilizer: DAP\nUsage: Adds phosphorus.\n";
            break;
        case MOPs:
            cout << "Fertilizer: MOP\nUsage: Boosts potassium levels.\n";
            break;
        default:
            cout << "Invalid fertilizer.\n";
    }
}


// --- Pest Management --- //
struct Pest {
    string name;
    string description;
    string treatment;
};

vector<Pest> pests = {
    {"Aphids", "Small sap-sucking insects.", "Use insecticidal soap or neem oil."},
    {"Whiteflies", "Small white flying insects.", "Introduce natural predators like ladybugs."},
    // Add more pests and their management strategies
};

void displayPestManagement() {
    cout << "\n--- Pest Management Strategies ---" << endl;
    for (const auto& pest : pests) {
        cout << "Pest: " << pest.name
             << ", Description: " << pest.description
             << ", Treatment: " << pest.treatment << endl;
    }
}

// In the main menu, add options to access these new features


enum Nutrients { NITROGENs, PHOSPHORUSs, POTASSIUMs, NUTRIENT_COUNTs };

vector<string> nutrientss = {"Nitrogens", "Phosphoruss", "Potassiums"};

void handleNutrients(int nutrientsID) {
    switch (nutrientsID) {
        case NITROGENs:
            cout << "Nutrient: Nitrogen\nRecommendation: Use compost.\n";
            break;
        case PHOSPHORUSs:
            cout << "Nutrient: Phosphorus\nRecommendation: Apply phosphate fertilizers.\n";
            break;
        case POTASSIUMs:
            cout << "Nutrient: Potassium\nRecommendation: Use potash-rich amendments.\n";
            break;
        default:
            cout << "Invalid nutrient.\n";
    }
}



enum IrrigationTypess { DRIPss, SPRINKLERss, FURROWss, IRRIGATION_COUNTss };

vector<string> irrigationMethodss = {"Dripss", "Sprinklerss", "Furrowss"};

void handleIrrigationss(int irrigationssID) {
    switch (irrigationssID) {
        case DRIPss:
            cout << "Irrigation: Drip\nEfficiency: 90%.\nSuitable for: Vegetables.\n";
            break;
        case SPRINKLERss:
            cout << "Irrigation: Sprinkler\nEfficiency: 70%.\nSuitable for: Large fields.\n";
            break;
        case FURROWss:
            cout << "Irrigation: Furrow\nEfficiency: 50%.\nSuitable for: Orchards.\n";
            break;
        default:
            cout << "Invalid irrigation method.\n";
    }
}


struct SoilHealth3 {
    string nutrientType; // e.g., Nitrogen, Phosphorus, Potassium
    double level; // Level of the nutrient
    string recommendation; // Recommendation based on the level
};

vector<SoilHealth3> soilHealthData =
{
    {"Nitrogen", 30.0, "Consider adding organic fertilizers."},
    {"Phosphorus", 15.0, "Optimal level, maintain current practices."},
    {"Potassium", 20.0, "Add potassium-rich fertilizers."}
    // Add more nutrients and their levels
};

void displaySoilHealth() {
    cout << "\n--- Soil Health Monitoring ---" << endl;
    for (const auto& soil : soilHealthData) {
        cout << "Nutrient: " << soil.nutrientType
             << ", Level: " << soil.level
             << ", Recommendation: " << soil.recommendation << endl;
    }
}

struct WeatherForecast
{
    string date;
    double temperature;
    double rainfall;
    double sunlight;
};

vector<WeatherForecast> weatherForecasts = {
    {"2023-10-01", 25.0, 10.0, 8.0},
    {"2023-10-02", 27.0, 5.0, 9.0},
    // Add more forecast data
};

void displayWeatherForecast()
{
    cout << "\n--- Weather Forecast ---" << endl;
    for (const auto& forecast : weatherForecasts) {
        cout << "Date: " << forecast.date
             << ", Temperature: " << forecast.temperature
             << "C, Rainfall: " << forecast.rainfall
             << "mm, Sunlight: " << forecast.sunlight << " hours" << endl;
    }
}


struct IrrigationSchedule3
{
    string cropName;
    string irrigationMethod; // e.g., Drip, Sprinkler
    double frequency; // Frequency in days
};

vector<IrrigationSchedule3> irrigationSchedules3= {
    {"Tomatoes", "Drip", 3},
    {"Spinach", "Sprinkler", 5}
    // Add more crops and their irrigation schedules
};

void displayIrrigationSchedules3()
{
    cout << "\n--- Irrigation Management ---" << endl;
    for (const auto& schedule : irrigationSchedules3) {
        cout << "Crop: " << schedule.cropName
             << ", Method: " << schedule.irrigationMethod
             << ", Frequency: every " << schedule.frequency << " days" << endl;
    }
}


struct PestDisease
{
    string name;
    string symptoms;
    string controlMeasures;
};

vector<PestDisease> pestDiseases = {
    {"Powdery Mildew", "White powdery spots on leaves.", "Use fungicides and improve air circulation."},
    {"Root Rot", "Wilting and yellowing of plants.", "Improve drainage and avoid overwatering."},
    // Add more pests and diseases
};

void displayPestDiseaseInfo()
{
    cout << "\n--- Pest and Disease Tracking ---" << endl;
    for (const auto& pd : pestDiseases) {
        cout << "Name: " << pd.name
             << ", Symptoms: " << pd.symptoms
             << ", Control Measures: " << pd.controlMeasures << endl;
    }
}


struct CropYield
{
    string cropName;
    double yield; // in tons
    string year;
};

vector<CropYield> cropYieldHistory = {
    {"Tomatoes", 10.5, "2022"},
    {"Spinach", 8.0, "2022"},
    // Add more yield data
};

void displayCropYieldHistory()
{
    cout << "\n--- Crop Yield History ---" << endl;
    for (const auto& yield : cropYieldHistory) {
        cout << "Crop: " << yield.cropName
             << ", Yield: " << yield.yield
             << " tons, Year: " << yield.year << endl;
    }
}


struct MarketPrice
{
    string cropName;
    double pricePerTon; // in currency units
    string date;
};

vector<MarketPrice> marketPrices = {
    {"Tomatoes", 200.0, "2023-10-01"},
    {"Spinach", 150.0, "2023-10-01"},
    {"Lettuce", 180.0, "2023-10-01"},
    {"Carrots", 120.0, "2023-10-01"},
    {"Peppers", 220.0, "2023-10-01"},
    // Add more crops and their market prices
};

void displayMarketPrices()
{
    cout << "\n--- Market Price Tracking ---" << endl;
    for (const auto& price : marketPrices) {
        cout << "Crop: " << price.cropName
             << ", Price per Ton: " << price.pricePerTon
             << " currency units, Date: " << price.date << endl;
    }
}


struct HarvestPlan
{
    string cropName;
    string harvestDate; // Expected harvest date
    double expectedYield; // Expected yield in tons
};

vector<HarvestPlan> harvestPlans = {
    {"Tomatoes", "2023-10-15", 12.0},
    {"Spinach", "2023-10-10", 8.0},
    // Add more harvest plans
};

void displayHarvestPlans()
{
    cout << "\n--- Harvest Planning ---" << endl;
    for (const auto& plan : harvestPlans) {
        cout << "Crop: " << plan.cropName
             << ", Expected Harvest Date: " << plan.harvestDate
             << ", Expected Yield: " << plan.expectedYield << " tons" << endl;
    }
}


struct Equipment
{
    string name;
    double cost; // Cost of the equipment
    string maintenanceSchedule; // e.g., "Every 6 months"
};

vector<Equipment> equipmentList = {
    {"Tractor", 25000.0, "Every 6 months"},
    {"Plow", 1500.0, "Annually"},
    {"Irrigation System", 5000.0, "Every 2 years"},
    // Add more equipment
};

void displayEquipmentManagement()
{
    cout << "\n--- Equipment Management ---" << endl;
    for (const auto& equipment : equipmentList) {
        cout << "Equipment: " << equipment.name
             << ", Cost: " << equipment.cost
             << " currency units, Maintenance Schedule: " << equipment.maintenanceSchedule << endl;
    }
}


struct Employee
{
    string name;
    string role; // e.g., "Farm Worker", "Manager"
    double salary; // Monthly salary
};

vector<Employee> employees = {
    {"John Doe", "Farm Worker", 1500.0},
    {"Jane Smith", "Manager", 3000.0},
    // Add more employees
};

void displayEmployeeManagement()
{
    cout << "\n--- Employee Management ---" << endl;
    for (const auto& employee : employees) {
        cout << "Name: " << employee.name
             << ", Role: " << employee.role
             << ", Salary: " << employee.salary << " currency units" << endl;
    }
}

struct SoilMoisture3
{
    string location;
    double moistureLevel;
};

vector<SoilMoisture3> soilMoistureData = {
    {"Field A", 30.0},
    {"Field B", 45.0},
    {"Field C", 25.0}
};

void displaySoilMoisture()
{
    for (const auto& moisture : soilMoistureData)
    {
        cout << "Location: " << moisture.location
             << ", Moisture Level: " << moisture.moistureLevel << "%" << endl;
    }
}


enum CropType {
    TOMATOES, SPINACH, LETTUCE, CARROTS, PEPPERS,
    CUCUMBERS, EGGPLANTS, BASIL, MINT, PARSLEY,
    KALE, BROCCOLI, CAULIFLOWER, ZUCCHINI, STRAWBERRIES,
    BEANS, PEAS, CHARD, CORIANDER, THYME,
    CROP_COUNT // To track the number of crops
};


enum EquipmentType {
    TRACTOR, PLOW, IRRIGATION_SYSTEM, HARVESTER, SPRAYER,
    EQUIPMENT_COUNT
};

vector<string> equipmentNames = {
    "Tractor", "Plow", "Irrigation System", "Harvester", "Sprayer"
};

void handleEquipment(int equipmentID)
{
    switch (equipmentID) {
        case TRACTOR:
            cout << "Selected equipment: Tractor\n";
            cout << "Maintenance: Every 6 months.\n";
            cout << "Cost: $25,000.\n";
            break;
        case PLOW:
            cout << "Selected equipment: Plow\n";
            cout << "Maintenance: Annually.\n";
            cout << "Cost: $1,500.\n";
            break;
        case IRRIGATION_SYSTEM:
            cout << "Selected equipment: Irrigation System\n";
            cout << "Maintenance: Every 2 years.\n";
            cout << "Cost: $5,000.\n";
            break;
        case HARVESTER:
            cout << "Selected equipment: Harvester\n";
            cout << "Maintenance: Every year.\n";
            cout << "Cost: $50,000.\n";
            break;
        case SPRAYER:
            cout << "Selected equipment: Sprayer\n";
            cout << "Maintenance: Every season.\n";
            cout << "Cost: $2,000.\n";
            break;
        default:
            cout << "Invalid equipment ID. Please select a valid option.\n";
            break;
    }
}

void testEquipmentSwitch()
{
    int choice;
    cout << "Select an equipment:\n";
    for (size_t i = 0; i < equipmentNames.size(); i++) {
        cout << i << ". " << equipmentNames[i] << endl;
    }
    cout << "Enter your choice: ";
    cin >> choice;

    if (choice >= 0 && choice < EQUIPMENT_COUNT) {
        handleEquipment(choice);
    } else {
        cout << "Invalid selection. Try again.\n";
    }
}

enum PestType {
    APHIDS, WHITEFLIES, POWDERY_MILDEW, ROOT_ROT, CUTWORMS,
    PEST_COUNT
};

vector<string> pestNames = {
    "Aphids", "Whiteflies", "Powdery Mildew", "Root Rot", "Cutworms"
};

void handlePest(int pestID)
{
    switch (pestID) {
        case APHIDS:
            cout << "Pest: Aphids\n";
            cout << "Control: Use insecticidal soap or neem oil.\n";
            break;
        case WHITEFLIES:
            cout << "Pest: Whiteflies\n";
            cout << "Control: Introduce natural predators like ladybugs.\n";
            break;
        case POWDERY_MILDEW:
            cout << "Pest: Powdery Mildew\n";
            cout << "Control: Apply fungicides and improve air circulation.\n";
            break;
        case ROOT_ROT:
            cout << "Pest: Root Rot\n";
            cout << "Control: Improve drainage and avoid overwatering.\n";
            break;
        case CUTWORMS:
            cout << "Pest: Cutworms\n";
            cout << "Control: Use physical barriers and handpick the pests.\n";
            break;
        default:
            cout << "Invalid pest ID. Please select a valid option.\n";
            break;
    }
}

void testPestSwitch()
{
    int choice;
    cout << "Select a pest:\n";
    for (size_t i = 0; i < pestNames.size(); i++) {
        cout << i << ". " << pestNames[i] << endl;
    }
    cout << "Enter your choice: ";
    cin >> choice;

    if (choice >= 0 && choice < PEST_COUNT) {
        handlePest(choice);
    } else {
        cout << "Invalid selection. Try again.\n";
    }
}


// Enumeration for soil improvement methods
enum SoilImprovementType {
    ROTATE_CROPS, USE_COMPOST, BALANCE_PH, MULCHING, IMPROVE_DRAINAGE,
    SOIL_COUNT
};

vector<string> soilMethods = {
    "Rotate Crops", "Use Compost", "Balance Soil pH", "Mulching", "Improve Drainage"
};

void handleSoilImprovement(int methodID)
{
    switch (methodID) {
        case ROTATE_CROPS:
            cout << "Method: Rotate Crops\n";
            cout << "Details: Preserve soil nutrients and reduce pests.\n";
            break;
        case USE_COMPOST:
            cout << "Method: Use Compost\n";
            cout << "Details: Improve soil structure and organic matter content.\n";
            break;
        case BALANCE_PH:
            cout << "Method: Balance Soil pH\n";
            cout << "Details: Test soil pH and adjust with lime or sulfur as needed.\n";
            break;
        case MULCHING:
            cout << "Method: Mulching\n";
            cout << "Details: Retain moisture and reduce weeds.\n";
            break;
        case IMPROVE_DRAINAGE:
            cout << "Method: Improve Drainage\n";
            cout << "Details: Use raised beds or add sand to compacted soil.\n";
            break;
        default:
            cout << "Invalid method ID. Please select a valid option.\n";
            break;
    }
}

void testSoilSwitch()
{
    int choice;
    cout << "Select a soil improvement method:\n";
    for (size_t i = 0; i < soilMethods.size(); i++) {
        cout << i << ". " << soilMethods[i] << endl;
    }
    cout << "Enter your choice: ";
    cin >> choice;

    if (choice >= 0 && choice < SOIL_COUNT) {
        handleSoilImprovement(choice);
    } else {
        cout << "Invalid selection. Try again.\n";
    }
}




// Vector of crop names
vector<string> cropNamess = {
    "Tomatoes", "Spinach", "Lettuce", "Carrots", "Peppers",
    "Cucumbers", "Eggplants", "Basil", "Mint", "Parsley",
    "Kale", "Broccoli", "Cauliflower", "Zucchini", "Strawberries",
    "Beans", "Peas", "Chard", "Coriander", "Thyme"
};

// Function to demonstrate switch-like behavior
void handleCrop(int cropID)
{
    switch (cropID) {
        case TOMATOES:
            cout << "Selected crop: Tomatoes\n";
            cout << "Suggestions: Use drip irrigation and organic fertilizer.\n";
            break;
        case SPINACH:
            cout << "Selected crop: Spinach\n";
            cout << "Suggestions: Ensure sufficient sunlight and regular watering.\n";
            break;
        case LETTUCE:
            cout << "Selected crop: Lettuce\n";
            cout << "Suggestions: Plant in cooler temperatures and keep the soil moist.\n";
            break;
        // Add other cases here
        case CARROTS:
            cout << "Selected crop: Carrots\n";
            cout << "Suggestions: Use sandy soil and avoid waterlogging.\n";
            break;
        default:
            cout << "Invalid crop ID. Please select a valid crop.\n";
            break;
    }
}

// Main-like function to test crop handling
void testCropSwithch()
{
    int choice;
    cout << "Select a crop:\n";
    for (size_t i = 0; i < cropNames.size(); i++) {
        cout << i << ". " << cropNames[i] << endl;
    }
    cout << "Enter your choice: ";
    cin >> choice;

    if (choice >= 0 && choice < CROP_COUNT) {
        handleCrop(choice);
    } else {
        cout << "Invalid selection. Try again.\n";
    }
}


enum HarvestSeason { SPRING, SUMMER, AUTUMN, WINTER, SEASON_COUNT };

vector<string> harvestSeasons = {"Spring", "Summer", "Autumn", "Winter"};

void handleHarvest(int seasonID) {
    switch (seasonID) {
        case SPRING:
            cout << "Season: Spring\nCrops: Spinach, Lettuce.\n";
            break;
        case SUMMER:
            cout << "Season: Summer\nCrops: Tomatoes, Peppers.\n";
            break;
        case AUTUMN:
            cout << "Season: Autumn\nCrops: Carrots, Kale.\n";
            break;
        case WINTER:
            cout << "Season: Winter\nCrops: Broccoli, Cabbage.\n";
            break;
        default:
            cout << "Invalid season.\n";
    }
}


enum MarketCrop { CORN, RICE, WHEAT, SUGAR, MARKET_CROP_COUNT };

vector<string> marketCrops = {"Corn", "Rice", "Wheat", "Sugar"};

void handleMarketPrice(int cropID) {
    switch (cropID) {
        case CORN:
            cout << "Crop: Corn\nPrice: $200 per ton.\n";
            break;
        case RICE:
            cout << "Crop: Rice\nPrice: $300 per ton.\n";
            break;
        case WHEAT:
            cout << "Crop: Wheat\nPrice: $250 per ton.\n";
            break;
        case SUGAR:
            cout << "Crop: Sugar\nPrice: $400 per ton.\n";
            break;
        default:
            cout << "Invalid crop.\n";
    }
}


// Agri function for testing purposes
void agriFunction() {
    cout << "This is an agri function for testing agricultural logic." << endl;

    // Simulate some computations relevant to agriculture
    double cropYield = 0;
    for (int i = 1; i <= 10; i++) {
        cropYield += i * 1.5; // Simulating yield increase
    }

    // Output the result (for demonstration only)
    cout << "Simulated total crop yield for 10 plots: " << cropYield << " tons." << endl;
}


enum Nutrient { NITROGEN, PHOSPHORUS, POTASSIUM, NUTRIENT_COUNT };

vector<string> nutrients = {"Nitrogen", "Phosphorus", "Potassium"};

void handleNutrient(int nutrientID) {
    switch (nutrientID) {
        case NITROGEN:
            cout << "Nutrient: Nitrogen\nRecommendation: Use compost.\n";
            break;
        case PHOSPHORUS:
            cout << "Nutrient: Phosphorus\nRecommendation: Apply phosphate fertilizers.\n";
            break;
        case POTASSIUM:
            cout << "Nutrient: Potassium\nRecommendation: Use potash-rich amendments.\n";
            break;
        default:
            cout << "Invalid nutrient.\n";
    }
}


enum Fertilizer { UREA, DAP, MOP, FERTILIZER_COUNT };

vector<string> fertilizers = {"Urea", "DAP", "MOP"};

void handleFertilizer(int fertilizerID) {
    switch (fertilizerID) {
        case UREA:
            cout << "Fertilizer: Urea\nUsage: Increases nitrogen levels.\n";
            break;
        case DAP:
            cout << "Fertilizer: DAP\nUsage: Adds phosphorus.\n";
            break;
        case MOP:
            cout << "Fertilizer: MOP\nUsage: Boosts potassium levels.\n";
            break;
        default:
            cout << "Invalid fertilizer.\n";
    }
}


enum SeedType { HYBRID, HEIRLOOM, ORGANIC, SEED_COUNT };

vector<string> seedTypes = {"Hybrid", "Heirloom", "Organic"};

void handleSeedSelection(int seedID) {
    switch (seedID) {
        case HYBRID:
            cout << "Seed: Hybrid\nDetails: High yield but requires controlled conditions.\n";
            break;
        case HEIRLOOM:
            cout << "Seed: Heirloom\nDetails: Traditional variety, open-pollinated, and flavorful.\n";
            break;
        case ORGANIC:
            cout << "Seed: Organic\nDetails: Certified organic, chemical-free production.\n";
            break;
        default:
            cout << "Invalid seed selection.\n";
    }
}


enum PestDiseases { BLIGHT, MILDEW, WILT, PEST_DISEASE_COUNT };

vector<string> pestDiseasess = {"Blight", "Mildew", "Wilt"};

void handlePestDisease(int diseaseID) {
    switch (diseaseID) {
        case BLIGHT:
            cout << "Disease: Blight\nControl: Use resistant varieties and apply fungicides.\n";
            break;
        case MILDEW:
            cout << "Disease: Mildew\nControl: Improve air circulation and use sulfur sprays.\n";
            break;
        case WILT:
            cout << "Disease: Wilt\nControl: Rotate crops and avoid waterlogging.\n";
            break;
        default:
            cout << "Invalid pest or disease.\n";
    }
}


enum WeatherAlertsType { FLOODs, DROUGHTs, FROSTs, STORMs, WEATHER_ALERT_COUNTs };

vector<string> weatherAlertss = {"Floods", "Droughts", "Frosts", "Storms"};

void handleWeatherAlerts(int alertID) {
    switch (alertID) {
        case FLOODs:
            cout << "Alert: Flood\nPrecautions: Evacuate low-lying areas immediately.\n";
            break;
        case DROUGHTs:
            cout << "Alert: Drought\nPrecautions: Conserve water and irrigate wisely.\n";
            break;
        case FROSTs:
            cout << "Alert: Frost\nPrecautions: Cover crops to protect them.\n";
            break;
        case STORMs:
            cout << "Alert: Storm\nPrecautions: Secure loose items and stay indoors.\n";
            break;
        default:
            cout << "Invalid weather alert.\n";
    }
}


enum UrbanTechnique { HYDROPONICS, VERTICAL_GARDENING, ROOFTOP_FARMING, URBAN_TECH_COUNT };

vector<string> urbanTechniques = {"Hydroponics", "Vertical Gardening", "Rooftop Farming"};

void handleUrbanTechnique(int techniqueID) {
    switch (techniqueID) {
        case HYDROPONICS:
            cout << "Technique: Hydroponics\nDetails: Soilless farming using nutrient-rich water.\n";
            break;
        case VERTICAL_GARDENING:
            cout << "Technique: Vertical Gardening\nDetails: Space-saving method, ideal for urban spaces.\n";
            break;
        case ROOFTOP_FARMING:
            cout << "Technique: Rooftop Farming\nDetails: Utilize rooftops for vegetable and herb cultivation.\n";
            break;
        default:
            cout << "Invalid technique.\n";
    }
}


enum AquaponicsComponent { FISH_TANK, GROW_BEDS, WATER_PUMPS, AQUAPONICS_COUNT };

vector<string> aquaponicsComponents = {"Fish Tank", "Grow Beds", "Water Pumps"};

void handleAquaponicsComponent(int componentID) {
    switch (componentID) {
        case FISH_TANK:
            cout << "Component: Fish Tank\nDetails: Houses fish for nutrient production.\n";
            break;
        case GROW_BEDS:
            cout << "Component: Grow Beds\nDetails: Holds plants that filter water.\n";
            break;
        case WATER_PUMPS:
            cout << "Component: Water Pumps\nDetails: Circulates water between tanks and beds.\n";
            break;
        default:
            cout << "Invalid component.\n";
    }
}


enum TransportMethodz { TRUCKsz, TRACTORsz, MANUAL_LABORz, TRANSPORT_COUNTz };

vector<string> transportMethodsz = {"Truckz", "Tractorz", "Manual Laborz"};

void handleTransportz(int methodzID) {
    switch (methodzID) {
        case TRUCKsz:
            cout << "Transport: Truck\nDetails: Best for long distances and large loads.\n";
            break;
        case TRACTORsz:
            cout << "Transport: Tractor\nDetails: Ideal for on-farm or nearby delivery.\n";
            break;
        case MANUAL_LABORz:
            cout << "Transport: Manual Labor\nDetails: Effective for small-scale operations.\n";
            break;
        default:
            cout << "Invalid transport method.\n";
    }
}


enum CropVarietyz { RICE_BASMATIz, WHEAT_DURUMz, MAIZE_SWEETz, VARIETY_COUNTz };

vector<string> cropVarietiesz = {"Ricez (Basmati)", "Wheatz (Durum)", "Maizez (Sweet)"};

void handleCropVarietyz(int varietyzID) {
    switch (varietyzID) {
        case RICE_BASMATIz:
            cout << "Variety: Rice (Basmati)\nDetails: High-quality aromatic variety, export grade.\n";
            break;
        case WHEAT_DURUMz:
            cout << "Variety: Wheat (Durum)\nDetails: Preferred for pasta production.\n";
            break;
        case MAIZE_SWEETz:
            cout << "Variety: Maize (Sweet)\nDetails: Ideal for fresh consumption.\n";
            break;
        default:
            cout << "Invalid variety.\n";
    }
}

enum MaintenanceFrequency { MONTHLY, QUARTERLY, YEARLY, MAINTENANCE_COUNT };

vector<string> frequencies = {"Monthly", "Quarterly", "Yearly"};

void handleMaintenance(int freqID) {
    switch (freqID) {
        case MONTHLY:
            cout << "Maintenance: Monthly\nEquipment: Irrigation systems.\n";
            break;
        case QUARTERLY:
            cout << "Maintenance: Quarterly\nEquipment: Sprayers.\n";
            break;
        case YEARLY:
            cout << "Maintenance: Yearly\nEquipment: Tractors.\n";
            break;
        default:
            cout << "Invalid frequency.\n";
    }
}


enum YieldYears { YEARs_2021, YEARs_2022, YEARs_2023, YEARs_2024, YEARs_COUNT };

vector<string> yieldYearss = {"2021", "2022", "2023", "2024"};

void handleYieldHistorys(int yearsID) {
    switch (yearsID) {
        case YEARs_2021:
            cout << "Year: 2021\nCrop: Tomatoes\nYield: 12 tons.\n";
            break;
        case YEARs_2022:
            cout << "Year: 2022\nCrop: Spinach\nYield: 10 tons.\n";
            break;
        case YEARs_2023:
            cout << "Year: 2023\nCrop: Lettuce\nYield: 15 tons.\n";
            break;
        case YEARs_2024:
            cout << "Year: 2024\nCrop: Carrots\nYield: 18 tons.\n";
            break;
        default:
            cout << "Invalid year.\n";
    }
}



enum BeeProduct { HONEY, WAX, ROYAL_JELLY, POLLEN, BEE_PRODUCT_COUNT };

vector<string> beeProducts = {"Honey", "Wax", "Royal Jelly", "Pollen"};

void handleBeeProduct(int productID) {
    switch (productID) {
        case HONEY:
            cout << "Product: Honey\nUsage: Food, medicine.\n";
            break;
        case WAX:
            cout << "Product: Wax\nUsage: Candles, polish.\n";
            break;
        case ROYAL_JELLY:
            cout << "Product: Royal Jelly\nUsage: Health supplement.\n";
            break;
        case POLLEN:
            cout << "Product: Pollen\nUsage: Food additive.\n";
            break;
        default:
            cout << "Invalid product.\n";
    }
}


struct CropVariety
{
    string cropName;
    string variety;
};

vector<CropVariety> cropVarieties = {
    {"Tomatoes", "Roma"},
    {"Tomatoes", "Cherry"},
    {"Spinach", "Savoy"}
};

void displayCropVarieties()
{
    for (const auto& variety : cropVarieties) {
        cout << "Crop: " << variety.cropName
             << ", Variety: " << variety.variety << endl;
    }
}


enum WateringSchedule { DAILY, WEEKLY, BIWEEKLY, SCHEDULE_COUNT };

vector<string> wateringSchedules = {"Daily", "Weekly", "Biweekly"};

void handleWateringSchedule(int scheduleID) {
    switch (scheduleID) {
        case DAILY:
            cout << "Schedule: Daily\nCrops: Spinach, Lettuce.\n";
            break;
        case WEEKLY:
            cout << "Schedule: Weekly\nCrops: Wheat, Barley.\n";
            break;
        case BIWEEKLY:
            cout << "Schedule: Biweekly\nCrops: Potatoes, Onions.\n";
            break;
        default:
            cout << "Invalid schedule.\n";
    }
}


enum ExportCrop { APPLES, ORANGES, GRAPES, EXPORT_CROP_COUNT };

vector<string> exportCrops = {"Apples", "Oranges", "Grapes"};

void handleExportCrop(int cropID) {
    switch (cropID) {
        case APPLES:
            cout << "Crop: Apples\nMarkets: USA, Europe.\n";
            break;
        case ORANGES:
            cout << "Crop: Oranges\nMarkets: Middle East, Asia.\n";
            break;
        case GRAPES:
            cout << "Crop: Grapes\nMarkets: Europe, Australia.\n";
            break;
        default:
            cout << "Invalid export crop.\n";
    }
}


enum WeatherType { SUNNY, RAINY, WINDY, WEATHER_TYPE_COUNT };

vector<string> weatherTypes = {"Sunny", "Rainy", "Windy"};

void handleWeatherForecast(int weatherID) {
    switch (weatherID) {
        case SUNNY:
            cout << "Weather: Sunny\nAdvice: Irrigate crops to prevent drying.\n";
            break;
        case RAINY:
            cout << "Weather: Rainy\nAdvice: Avoid overwatering and manage drainage.\n";
            break;
        case WINDY:
            cout << "Weather: Windy\nAdvice: Secure plants and support structures.\n";
            break;
        default:
            cout << "Invalid weather type.\n";
    }
}


enum WorkerTask { PLANTING, HARVESTING, WEEDING, TASK_COUNT };

vector<string> workerTasks = {"Planting", "Harvesting", "Weeding"};

void handleWorkerTask(int taskID) {
    switch (taskID) {
        case PLANTING:
            cout << "Task: Planting\nDetails: Assign workers to prepare soil and plant seeds.\n";
            break;
        case HARVESTING:
            cout << "Task: Harvesting\nDetails: Harvest ripe crops for transport.\n";
            break;
        case WEEDING:
            cout << "Task: Weeding\nDetails: Remove weeds to improve crop health.\n";
            break;
        default:
            cout << "Invalid task.\n";
    }
}




struct Pesticide
{
    string name;
    string targetPest;
};

vector<Pesticide> pesticides =
{
    {"Insecticide A", "Aphids"},
    {"Fungicide B", "Powdery Mildew"},
    {"Herbicide C", "Weeds"}
};

void displayPesticideManagement()
{
    for (const auto& pesticide : pesticides) {
        cout << "Pesticide: " << pesticide.name
             << ", Target Pest: " << pesticide.targetPest << endl;
    }
}
struct YieldForecast
{
    string cropName;
    double predictedYield;
};

vector<YieldForecast> yieldForecasts = {
    {"Tomatoes", 15.0},
    {"Spinach", 10.0},
    {"Carrots", 12.5}
};

void displayYieldForecasts()
{
    for (const auto& forecast : yieldForecasts)
    {
        cout << "Crop: " << forecast.cropName
             << ", Predicted Yield: " << forecast.predictedYield << " tons" << endl;
    }
}

struct WeatherAlert
{
    string alertType;
    string description;
};

vector<WeatherAlert> weatherrAlerts = {
    {"Flood", "Heavy rainfall expected."},
    {"Drought", "Water restrictions in effect."},
    {"Frost", "Frost warning for tonight."}
};


enum IrrigationTypes { DRIPs, SPRINKLERs, FURROWs, IRRIGATION_COUNTs };

vector<string> irrigationsMethods = {"Drip", "Sprinkler", "Furrow"};

void handleIrrigations(int irrigationID) {
    switch (irrigationID) {
        case DRIP:
            cout << "Irrigation: Drip\nEfficiency: 90%.\nSuitable for: Vegetables.\n";
            break;
        case SPRINKLER:
            cout << "Irrigation: Sprinkler\nEfficiency: 70%.\nSuitable for: Large fields.\n";
            break;
        case FURROW:
            cout << "Irrigation: Furrow\nEfficiency: 50%.\nSuitable for: Orchards.\n";
            break;
        default:
            cout << "Invalid irrigation method.\n";
    }
}

void checkAirQuality()

{
    int pm25, no2;
    cout << "\n--- Air Quality Monitoring ---\n";
    cout << "Enter PM2.5 level (in ug/m3): ";
    cin >> pm25;
    cout << "Enter NO2 level (in ppb): ";
    cin >> no2;

    if (pm25 > 150 || no2 > 100)
    {
        cout << "Warning: Poor air quality detected! Take action immediately!" << endl;
        cout << "PM2.5: " << pm25 << " ug/m3 | NO2: " << no2 << " ppb\n";
        cout << "Suggested Action: Use biofilters, increase green areas, and reduce emissions.\n";
    }
    else
    {
        cout << "Air quality is within safe limits.\n";
    }
}

void checkWaterQuality()

{
    int ph, contaminants;
    cout << "\n--- Water Quality Monitoring ---\n";
    cout << "Enter water pH level: ";
    cin >> ph;
    cout << "Enter water contaminants (mg/L): ";
    cin >> contaminants;

    if (ph < 6.5 || ph > 8.5 || contaminants > 50)
    {
        cout << "Warning: Poor water quality detected! Take action immediately!" << endl;
        cout << "Water pH: " << ph << " | Contaminants: " << contaminants << " mg/L\n";
        cout << "Suggested Action: Implement water purification systems, use natural filtration.\n";
    }
    else
    {
        cout << "Water quality is within safe limits.\n";
    }
}



// Function for the second main logic

// Function for the fourth main logic
void displayMenu3()
{
    std::cout << "\n--- Urban Farming Environmental Monitoring System ---\n";
    std::cout << "1. Check Air Quality\n";
    std::cout << "2. Check Water Quality\n";
    std::cout << "3. Check Resource Consumption\n";
    std::cout << "4. Track Pollution Levels\n";
    std::cout << "5. Report Farm Status\n";
    std::cout << "6. Add Task to Queue\n";
    std::cout << "7. Process Pending Tasks\n";
    std::cout << "8. Exit\n";
    std::cout << "Enter your choice: ";
}

int getValidInteger()
{
    int input;
    while (true)
    {
        std::cin >> input;
        if (std::cin.fail())
        {
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            std::cout << "Invalid input! Please enter a valid integer: ";
        }
        else
        {
            return input;
        }
    }
}
struct Crop5
    {
    std::string name;
    int maturityDays;
    int currentGrowth;
    std::string plantingDate;
    std::string harvestStartDate; // Start date for harvest range
    std::string harvestEndDate;   // End date for harvest range (5 days after harvest start)
    double yieldPerAcre;          // Expected yield per acre
    double totalYield;            // Total yield

    Crop5(std::string n, int m, std::string p, double y = 0.0) :
    name(n), maturityDays(m), currentGrowth(0), plantingDate(p), yieldPerAcre(y), totalYield(0)
    {
        calculateHarvestDates(p, m); // Automatically calculate harvest date range
    }

    // Helper function to calculate harvest start and end dates
    void calculateHarvestDates(const std::string& plantingDate, int maturityDays)
    {
        int year = std::stoi(plantingDate.substr(0, 4));
        int month = std::stoi(plantingDate.substr(5, 2));
        int day = std::stoi(plantingDate.substr(8, 2));

        day += maturityDays;
        while (day > 30)
        {
            day -= 30;
            month++;
            if (month > 12)
            {
                month = 1;
                year++;
            }
        }

        harvestStartDate = std::to_string(year) + "-" + (month < 10 ? "0" : "") + std::to_string(month) + "-" + (day < 10 ? "0" : "") + std::to_string(day);

        day += 5;
        while (day > 30)
        {
            day -= 30;
            month++;
            if (month > 12)
            {
                month = 1;
                year++;
            }
        }

        harvestEndDate = std::to_string(year) + "-" + (month < 10 ? "0" : "") + std::to_string(month) + "-" + (day < 10 ? "0" : "") + std::to_string(day);
    }

    // Function to update the current growth status
    void updateGrowth(int days)
    {
        currentGrowth += days;
        if (currentGrowth > maturityDays)
        {
            currentGrowth = maturityDays;
        }
    }

    // Function to check if the crop is ready to be harvested
    bool isHarvestable(const std::string& currentDate)
    {
        return currentDate >= harvestStartDate && currentDate <= harvestEndDate;
    }

    // Function to calculate total yield based on the acreage
    void calculateTotalYield(double acreage)
    {
        totalYield = yieldPerAcre * acreage;
    }

    // Function to display crop information
    void displayInfo() const
    {
        std::cout << "Crop Name: " << name << std::endl;
        std::cout << "Maturity Days: " << maturityDays << std::endl;
        std::cout << "Current Growth: " << currentGrowth << " days" << std::endl;
        std::cout << "Planting Date: " << plantingDate << std::endl;
        std::cout << "Harvest Start Date: " << harvestStartDate << std::endl;
        std::cout << "Harvest End Date: " << harvestEndDate << std::endl;
        std::cout << "Yield per Acre: " << yieldPerAcre << " units" << std::endl;
        std::cout << "Total Yield: " << totalYield << " units" << std::endl;
    }

    // Function to get the remaining growth days
    int getRemainingGrowthDays() const
    {
        return maturityDays - currentGrowth;
    }

    // Function to check if the crop is mature
    bool isMature() const
    {
        return currentGrowth >= maturityDays;
    }

    // Function to simulate a growth period
    void simulateGrowthPeriod(int days)
    {
        updateGrowth(days);
        std::cout << "Simulated " << days << " days of growth. Current growth: " << currentGrowth << " days.\n";
    }

    // Function to reset crop growth
    void resetGrowth()
    {
        currentGrowth = 0;
        std::cout << "Growth reset. Current growth: " << currentGrowth << " days.\n";
    }

    // Function to update planting date and recalculate harvest dates
    void updatePlantingDate(const std::string& newPlantingDate)
    {
        plantingDate = newPlantingDate;
        calculateHarvestDates(newPlantingDate, maturityDays);
        std::cout << "Updated planting date to " << plantingDate << ". New harvest period: " << harvestStartDate << " to " << harvestEndDate << ".\n";
    }

    // New function: Check if the crop is past harvest date
    bool isPastHarvestEndDate(const std::string& currentDate) const
    {
        return currentDate > harvestEndDate;
    }

    // New function: Display detailed harvest information
    void displayHarvestInfo() const
    {
        std::cout << "Harvest Details for " << name << ":\n";
        std::cout << "Harvest Start Date: " << harvestStartDate << "\n";
        std::cout << "Harvest End Date: " << harvestEndDate << "\n";
        std::cout << "Yield per Acre: " << yieldPerAcre << " units\n";
        std::cout << "Total Yield: " << totalYield << " units\n";
    }

    // New function: Calculate and update yield based on actual harvested area
    void updateYieldBasedOnHarvestedArea(double harvestedArea)
    {
        totalYield = yieldPerAcre * harvestedArea;
        std::cout << "Updated total yield based on " << harvestedArea << " acres: " << totalYield << " units.\n";
    }

    // New function: Estimate the harvest time based on current growth
    std::string estimateHarvestTime() const
    {
        int remainingDays = maturityDays - currentGrowth;
        int year = std::stoi(plantingDate.substr(0, 4));
        int month = std::stoi(plantingDate.substr(5, 2));
        int day = std::stoi(plantingDate.substr(8, 2));

        day += remainingDays;
        while (day > 30)
        {
            day -= 30;
            month++;
            if (month > 12)
            {
                month = 1;
                year++;
            }
        }

        return std::to_string(year) + "-" + (month < 10 ? "0" : "") + std::to_string(month) + "-" + (day < 10 ? "0" : "") + std::to_string(day);
    }
};

class HarvestSchedule5
{

private:
    std::vector<Crop5> crops;
    std::map<std::string, int> transportationAvailability;
    std::string weatherPrediction;
    std::string date; // Store the date entered by the user for harvest schedule

public:

    void addCrop(const std::string& cropName, int maturityDays, const std::string& plantingDate, double yieldPerAcre = 0.0)
    {
        crops.emplace_back(cropName, maturityDays, plantingDate, yieldPerAcre);
    }

    void updateTransportationAvailability(const std::string& date, int capacity)
    {
        transportationAvailability[date] = capacity;
    }

    void generateHarvestSchedule(const std::string& weather, const std::string& date)
    {
        weatherPrediction = weather; // Save the weather prediction for later use in Option 7
        std::cout << "Generating Harvest Schedule for " << date << " under " << weather << " weather...\n";
        for (const auto& crop : crops)
        {
            std::cout << "Crop: " << crop.name
                      << ", Planting Date: " << crop.plantingDate
                      << ", Harvest Period: " << crop.harvestStartDate << " to " << crop.harvestEndDate
                      << " (" << (crop.maturityDays - crop.currentGrowth)
                      << " days to go)";
            if (weather == "Rainy")
            {
                std::cout << " [Harvesting might be delayed due to rain]";
            }
            std::cout << "\n";
        }
    }

    void displayPlantingSchedule() const
    {
        std::cout << "\n--- Crop Planting Schedule ---\n";
        for (const auto& crop : crops)
        {
            crop.displayInfo();
        }
    }

    std::string getWeatherPrediction() const
    {
        return weatherPrediction;
    }

    std::vector<Crop5> getCrops() const
    {
        return crops;
    }

    // New function: Find a crop by name
    Crop5* findCropByName(const std::string& cropName)
    {
        for (auto& crop : crops)
        {
            if (crop.name == cropName)
            {
                return &crop;
            }
        }
        return nullptr;
    }

    // New function: Remove a crop by name
    bool removeCropByName(const std::string& cropName)
    {
        auto it = std::remove_if(crops.begin(), crops.end(), [&](const Crop5& crop)
        {
            return crop.name == cropName;
        });
        if (it != crops.end())
        {
            crops.erase(it, crops.end());
            return true;
        }
        return false;
    }

    // New function: Sort crops by planting date
    void sortCropsByPlantingDate()
    {
        std::sort(crops.begin(), crops.end(), [](const Crop5& a, const Crop5& b)
        {
            return a.plantingDate < b.plantingDate;
        });
    }

    // New function: Display transportation availability
    void displayTransportationAvailability() const
    {
        std::cout << "\n--- Transportation Availability ---\n";
        for (const auto& entry : transportationAvailability)
        {
            std::cout << "Date: " << entry.first << ", Capacity: " << entry.second << "\n";
        }
    }

    // New function: Check transportation capacity for a specific date
    int getTransportationCapacity(const std::string& date) const
    {
        auto it = transportationAvailability.find(date);
        if (it != transportationAvailability.end())
        {
            return it->second;
        }
        return 0; // No capacity available for the given date
    }
};

class CropRotationPlanner1
{
private:
    std::map<std::string, std::vector<std::pair<std::string, int>>> cropRotations;

public:
    void addRotationPlan(const std::vector<Crop5>& crops, const std::string& fieldName)
    {
        std::vector<std::pair<std::string, int>> cropDetails;
        for (const auto& crop : crops)
        {
            cropDetails.emplace_back(crop.name, crop.maturityDays);
        }
        cropRotations[fieldName] = cropDetails;
    }

    void displayRotationPlans() const
    {
        if (cropRotations.empty())
        {
            std::cout << "No crop rotation plans available. Please add a rotation plan first.\n";
            return;
        }
        std::cout << "Crop Rotation Plans:\n";
        for (const auto& entry : cropRotations)
        {
            const std::string& fieldName = entry.first;
            const auto& crops = entry.second;

            std::cout << "Field: " << fieldName << " -> Crops:\n";

            int totalMaturityDays = 0;
            for (size_t i = 0; i < crops.size(); ++i)
            {
                size_t next = (i + 1) % crops.size();
                std::cout << crops[i].first << " (" << crops[i].second << " days) -> "
                          << crops[next].first << " (" << crops[next].second << " days)\n";
                totalMaturityDays += crops[i].second;
            }

            int freeDays = 365 - totalMaturityDays;
            if (freeDays > 0) {
                std::cout << "Remaining free days in the year: " << freeDays << " days.\n";
                std::cout << "Benefits of the fallow period:\n"
                          << "- Improves soil health through natural regeneration.\n"
                          << "- Helps in controlling weeds by breaking their growth cycle.\n"
                          << "- Retains soil moisture, reducing the need for irrigation.\n"
                          << "- Enhances soil temperature for better microbial activity.\n"
                          << "- Promotes biodiversity, encouraging beneficial organisms.\n";
            }
            else
            {
                std::cout << "No free days left. All days in the year are occupied by crops.\n";
            }
        }
    }

    // New function: Find rotation plan by field name
    std::vector<std::pair<std::string, int>> findRotationPlanByFieldName(const std::string& fieldName) const {
        auto it = cropRotations.find(fieldName);
        if (it != cropRotations.end())
        {
            return it->second;
        }
        return {}; // Return an empty vector if the field name is not found
    }

    // New function: Remove rotation plan by field name
    bool removeRotationPlanByFieldName(const std::string& fieldName)
    {
        return cropRotations.erase(fieldName) > 0;
    }

    // New function: Update rotation plan for a field
    bool updateRotationPlan(const std::string& fieldName, const std::vector<Crop5>& newCrops)
    {
        auto it = cropRotations.find(fieldName);
        if (it != cropRotations.end())
        {
            std::vector<std::pair<std::string, int>> cropDetails;
            for (const auto& crop : newCrops)
            {
                cropDetails.emplace_back(crop.name, crop.maturityDays);
            }
            it->second = cropDetails;
            return true;
        }
        return false;
    }

    // New function: List all fields
    void listAllFields() const
    {
        std::cout << "\n--- List of Fields ---\n";
        for (const auto& entry : cropRotations)
        {
            std::cout << "Field: " << entry.first << "\n";
        }
    }

    // New function: Display crop rotation details for a specific field
    void displayRotationPlanForField(const std::string& fieldName) const
    {
        auto it = cropRotations.find(fieldName);
        if (it != cropRotations.end())
        {
            std::cout << "Field: " << fieldName << " -> Crops:\n";
            const auto& crops = it->second;
            int totalMaturityDays = 0;
            for (size_t i = 0; i < crops.size(); ++i)
            {
                size_t next = (i + 1) % crops.size();
                std::cout << crops[i].first << " (" << crops[i].second << " days) -> "
                          << crops[next].first << " (" << crops[next].second << " days)\n";
                totalMaturityDays += crops[i].second;
            }

            int freeDays = 365 - totalMaturityDays;
            if (freeDays > 0)
            {
                std::cout << "Remaining free days in the year: " << freeDays << " days.\n";
                std::cout << "Benefits of the fallow period:\n"
                          << "- Improves soil health through natural regeneration.\n"
                          << "- Helps in controlling weeds by breaking their growth cycle.\n"
                          << "- Retains soil moisture, reducing the need for irrigation.\n"
                          << "- Enhances soil temperature for better microbial activity.\n"
                          << "- Promotes biodiversity, encouraging beneficial organisms.\n";
            }
            else
            {
                std::cout << "No free days left. All days in the year are occupied by crops.\n";
            }
        }
        else
        {
            std::cout << "Field: " << fieldName << " not found.\n";
        }
    }

    // New function: Display summary statistics for all fields
    void displaySummaryStatistics() const
    {
        std::cout << "\n--- Summary Statistics for All Fields ---\n";
        for (const auto& entry : cropRotations)
        {
            const std::string& fieldName = entry.first;
            const auto& crops = entry.second;
            int totalMaturityDays = 0;
            for (const auto& crop : crops)
            {
                totalMaturityDays += crop.second;
            }
            int freeDays = 365 - totalMaturityDays;
            std::cout << "Field: " << fieldName << "\n";
            std::cout << "Total Maturity Days: " << totalMaturityDays << "\n";
            std::cout << "Free Days: " << freeDays << "\n";
        }
    }

    // New function: Find the field with the most free days
    std::string findFieldWithMostFreeDays() const
    {
        std::string fieldWithMostFreeDays;
        int maxFreeDays = -1;
        for (const auto& entry : cropRotations)
        {
            const auto& crops = entry.second;
            int totalMaturityDays = 0;
            for (const auto& crop : crops)
            {
                totalMaturityDays += crop.second;
            }
            int freeDays = 365 - totalMaturityDays;
            if (freeDays > maxFreeDays)
            {
                maxFreeDays = freeDays;
                fieldWithMostFreeDays = entry.first;
            }
        }
        return fieldWithMostFreeDays;
    }
};
// Function for the second main logic
int mainOption2() {
    srand(time(0));

    // Crop options list with Rice, Wheat, and similar crops
    std::vector<std::string> crops = {
        "Rice", "Wheat", "Barley", "Corn", "Oats", "Soybeans", "Sorghum", "Millets",
        "Cotton", "Sugarcane", "Tomatoes", "Potatoes", "Carrots", "Peas", "Lettuce",
        "Onions", "Garlic", "Cabbage", "Spinach", "Radish", "Beans", "Chili", "Pumpkin",
        "Cucumber", "Broccoli", "Cauliflower", "Zucchini", "Strawberries", "Melons",
        "Pineapple", "Bananas", "Apples"
    };

    int choice;
    HarvestSchedule5 harvestSchedule;
    CropRotationPlanner1 cropRotationPlanner;
    ClimateAdaptiveFarming climateAdaptiveFarming;
    Graph graph;
    SoilTesting soilTesting;
    IrrigationSchedule irrigationSchedule;
    PestControlManagement pestControlManagement;
    YieldPrediction yieldPrediction;

    std::cout << "--------------------------------------------------\n";
    std::cout << "Welcome to the Advanced Farming Optimization System\n";
    std::cout << "This system helps you plan crop rotations, harvesting,\n";
    std::cout << "and adapts schedules based on weather conditions.\n";
    std::cout << "--------------------------------------------------\n";

    do
    {
        std::cout << "\n--- Farming Optimization System with Weather Impact ---\n";
        std::cout << "1. Add Crop for Harvesting\n";
        std::cout << "2. Display Crop Planting Schedule\n";
        std::cout << "3. Generate Harvest Schedule\n";
        std::cout << "4. Add Crop Rotation Plan\n";
        std::cout << "5. Display Crop Rotation Plans\n";
        std::cout << "6. Adjust Schedule for Weather\n";
        std::cout << "7. Set Transportation Availability\n";
        std::cout << "8. Find Shortest Path to Market\n";
        std::cout << "9. Check Land Suitability\n";
        std::cout << "10. Add Soil Test Result\n";
        std::cout << "11. Display Soil Testing History\n";
        std::cout << "12. Add Irrigation Schedule\n";
        std::cout << "13. Display Irrigation Schedules\n";
        std::cout << "14. Add Pest Control Activity\n";
        std::cout << "15. Display Pest Control Activities\n";
        std::cout << "16. Predict Crop Yield\n";
        std::cout << "17. Exit\n";
        std::cout << "Enter your choice: ";
        std::cin >> choice;

        switch (choice)
        {
            case 1:
            {
                char addAnotherCrop = 'y';
                while (addAnotherCrop == 'y' || addAnotherCrop == 'Y') {
                    std::cout << "--- Select Crop Type ---\n";
                    for (size_t i = 0; i < crops.size(); ++i) {
                        std::cout << (i + 1) << ". " << crops[i] << "\n";
                    }

                    int cropChoice;
                    std::cout << "Select a crop by entering the number: ";
                    std::cin >> cropChoice;

                    if (cropChoice < 1 || cropChoice > crops.size()) {
                        std::cout << "Invalid crop choice! Please try again.\n";
                    }
                    else
                    {
                        std::string cropName = crops[cropChoice - 1];
                        int maturityDays;
                        std::string plantingDate;
                        double yieldPerAcre;
                        std::cout << "Enter days to maturity for " << cropName << ": ";
                        std::cin >> maturityDays;
                        std::cout << "Enter planting date (YYYY-MM-DD): ";
                        std::cin >> plantingDate;
                        std::cout << "Enter expected yield per acre: ";
                        std::cin >> yieldPerAcre;

                        harvestSchedule.addCrop(cropName, maturityDays, plantingDate, yieldPerAcre);
                        std::cout << "Crop " << cropName << " added successfully!\n";
                    }

                    std::cout << "Would you like to add another crop? (y/n): ";
                    std::cin >> addAnotherCrop;
                }
                break;
            }
            case 2:
            {
                harvestSchedule.displayPlantingSchedule();
                break;
            }
            case 3:
            {
                std::string weather, date;
                std::cout << "Enter the date for harvest schedule (YYYY-MM-DD): ";
                std::cin >> date;
                std::cout << "Enter weather prediction (Sunny/Rainy): ";
                std::cin >> weather;

                harvestSchedule.generateHarvestSchedule(weather, date);
                break;
            }
            case 4:
            {
                std::string fieldName;
                std::vector<Crop5> rotationCrops;
                int numCrops;
                std::cout << "Enter field name: ";
                std::cin >> fieldName;
                std::cout << "Enter number of crops for rotation: ";
                std::cin >> numCrops;

                for (int i = 0; i < numCrops; ++i)
                {
                    std::string cropName;
                    int maturityDays;
                    double yieldPerAcre;
                    std::string plantingDate;
                    std::cout << "Enter crop name: ";
                    std::cin >> cropName;
                    std::cout << "Enter maturity days for " << cropName << ": ";
                    std::cin >> maturityDays;
                    std::cout << "Enter expected yield per acre: ";
                    std::cin >> yieldPerAcre;
                    std::cout << "Enter planting date (YYYY-MM-DD): ";
                    std::cin >> plantingDate;
                    rotationCrops.emplace_back(cropName, maturityDays, plantingDate, yieldPerAcre);
                }

                cropRotationPlanner.addRotationPlan(rotationCrops, fieldName);
                std::cout << "Crop rotation plan added for field " << fieldName << "!\n";
                break;
            }
            case 5:
            {
                cropRotationPlanner.displayRotationPlans();
                break;
            }
            case 6:
            {
                std::string weatherPrediction = harvestSchedule.getWeatherPrediction();
                climateAdaptiveFarming.adjustScheduleForWeather(weatherPrediction);
                break;
            }
            case 7:
            {
                std::string date;
                int capacity;
                std::cout << "Enter date for transportation (YYYY-MM-DD): ";
                std::cin >> date;
                std::cout << "Enter transportation capacity: ";
                std::cin >> capacity;
                harvestSchedule.updateTransportationAvailability(date, capacity);
                std::cout << "Transportation availability updated!\n";
                break;
            }
            case 8:
            {
                std::string start;
                std::cout << "Enter starting location: ";
                std::cin >> start;

                int numEdges;
                std::cout << "Enter the number of destinations: ";
                std::cin >> numEdges;
                for (int i = 0; i < numEdges; ++i)
                {
                    std::string v;
                    int weight;
                    std::cout << "Enter the end location: ";
                    std::cin >> v;
                    std::cout << "Enter the distance between " << start << " and " << v << ": ";
                    std::cin >> weight;
                    graph.addEdge(start, v, weight);
                }

                std::string target;
                std::cout << "Enter target market: ";
                std::cin >> target;

                std::vector<std::string> path = graph.dijkstra(start, target);
                if (path.size() > 1)
                {
                    std::cout << "Shortest path from " << start << " to " << target << ":\n";
                    for (const auto& node : path)
                    {
                        std::cout << node << " ";
                    }
                    std::cout << "\n";
                }
                else
                {
                    std::cout << "No path found from " << start << " to " << target << ".\n";
                }
                break;
            }
            case 9:
            {
                // Check Land Suitability
                double soilFertility, nutrientLevels, temperature, waterAvailability;

                std::cout << "Enter soil fertility level (0-100): ";
                std::cin >> soilFertility;
                std::cout << "Enter nutrient levels (0-100): ";
                std::cin >> nutrientLevels;
                std::cout << "Enter temperature (in Celsius): ";
                std::cin >> temperature;
                std::cout << "Enter water availability (0-100): ";
                std::cin >> waterAvailability;

                bool isSuitable = true;

                if (soilFertility < 50)
                {
                    std::cout << "Soil fertility is below the required level.\n";
                    isSuitable = false;
                }
                if (nutrientLevels < 50)
                {
                    std::cout << "Nutrient levels are insufficient.\n";
                    isSuitable = false;
                }
                if (temperature < 15 || temperature > 35)
                {
                    std::cout << "Temperature is not within the optimal range (15-35C).\n";
                    isSuitable = false;
                }
                if (waterAvailability < 50)
                {
                    std::cout << "Water availability is too low.\n";
                    isSuitable = false;
                }

                if (isSuitable)
                {
                    std::cout << "The agricultural land is valid for the next plantations.\n";
                }
                else
                {
                    std::cout << "The agricultural land is not suitable for the next plantations. Please take corrective actions.\n";
                }
                break;
            }
            case 10:
            {
                // Add Soil Test Result
                std::string date;
                double fertility, nutrients, temperature, water;

                std::cout << "Enter test date (YYYY-MM-DD): ";
                std::cin >> date;
                std::cout << "Enter soil fertility level: ";
                std::cin >> fertility;
                std::cout << "Enter nutrient levels: ";
                std::cin >> nutrients;
                std::cout << "Enter temperature (in Celsius): ";
                std::cin >> temperature;
                std::cout << "Enter water availability level: ";
                std::cin >> water;

                soilTesting.addSoilTestResult(date, fertility, nutrients, temperature, water);
                std::cout << "Soil test result added successfully!\n";
                break;
            }
            case 11:
            {
                // Display Soil Testing History
                soilTesting.displaySoilTests();
                break;
            }
            case 12:
            {
                // Add Irrigation Schedule
                std::string date, schedule;
                std::cout << "Enter irrigation date (YYYY-MM-DD): ";
                std::cin >> date;
                std::cout << "Enter irrigation schedule: ";
                std::cin.ignore();
                std::getline(std::cin, schedule);

                irrigationSchedule.addIrrigationSchedule(date, schedule);
                std::cout << "Irrigation schedule added successfully!\n";
                break;
            }
            case 13:
            {
                // Display Irrigation Schedules
                irrigationSchedule.displayIrrigationSchedules();
                break;
            }
            case 14:
            {
                // Add Pest Control Activity
                std::string date, activity;
                std::cout << "Enter pest control activity date (YYYY-MM-DD): ";
                std::cin >> date;
                std::cout << "Enter pest control activity: ";
                std::cin.ignore();
                std::getline(std::cin, activity);

                pestControlManagement.addPestControlActivity(date, activity);
                std::cout << "Pest control activity added successfully!\n";
                break;
            }
            case 15:
            {
                // Display Pest Control Activities
                pestControlManagement.displayPestControlActivities();
                break;
            }
            case 16:
            {
                // Predict Crop Yield
                double soilFertility, nutrientLevels, temperature, waterAvailability, acreage;

                std::cout << "Enter soil fertility level (0-100): ";
                std::cin >> soilFertility;
                std::cout << "Enter nutrient levels (0-100): ";
                std::cin >> nutrientLevels;
                std::cout << "Enter temperature (in Celsius): ";
                std::cin >> temperature;
                std::cout << "Enter water availability (0-100): ";
                std::cin >> waterAvailability;
                std::cout << "Enter acreage: ";
                std::cin >> acreage;

                double predictedYield = yieldPrediction.predictYield(soilFertility, nutrientLevels, temperature, waterAvailability, acreage);
                std::cout << "Predicted crop yield: " << predictedYield << " units\n";
                break;
            }
            case 17:
                std::cout << "Exiting...\n";
                break;
            default:
                std::cout << "Invalid choice! Please try again.\n";
        }
    }
    while (choice != 17);

    CropMonitoring cropMonitoring;
    LaborAndEquipmentManagement laborAndEquipment;
    EmergencyPreparedness emergencyPrep;
    Sustainability sustainability;

    std::cout << "===== Farm Management System =====\n";

    // Real-Time Crop Monitoring
    cropMonitoring.monitorCropHealth();
    cropMonitoring.monitorGrowth();

    // Labor and Equipment Management
    std::string activity;
    int labor, equipment;
    std::cout << "Enter activity (e.g., Harvesting, Planting): ";
    std::cin >> activity;
    std::cout << "Enter number of workers for " << activity << ": ";
    std::cin >> labor;
    std::cout << "Enter number of equipment units for " << activity << ": ";
    std::cin >> equipment;
    laborAndEquipment.allocateResources(activity, labor, equipment);
    laborAndEquipment.displayAllocations();

    // Emergency Preparedness
    std::string weatherEvent;
    std::cout << "Enter weather event (storm, frost, flood): ";
    std::cin >> weatherEvent;
    emergencyPrep.respondToWeatherChange(weatherEvent);

    // Sustainability and Carbon Footprint Reduction
    std::string practice;
    std::cout << "Enter sustainability practice (no-till farming, cover crops, renewable energy): ";
    std::cin >> practice;
    sustainability.reduceEmissions(practice);

    return 0;
}

// Function for the third main logic
void mainOption3() {
    int mainChoice;
    string selectedCrop = "None";
    double yieldAmount = 0;

    placeholderFunction1();
    placeholderFunction2();

    do {
        showMainMenu();
        std::cin >> mainChoice;

        switch (mainChoice)
        {
            case 1:
            {
                int cropChoice;
                showCropMenu();
                std::cin >> cropChoice;
                if (cropChoice >= 1 && cropChoice <= cropNames.size())
                {
                    selectedCrop = cropNames[cropChoice - 1];
                    std::cout << "Selected Crop: " << selectedCrop << std::endl;
                } else
                {
                    std::cout << "Invalid crop choice. Please try again." << std::endl;
                }
                break;
            }
            case 2: {
                // Weather-Based Yield Prediction
                vector<WeatherData> weatherHistory;

                simulateWeatherData(weatherHistory, 100); // Generate 100 data points

                WeatherData currentWeather = {28, 90, 9};

                double yieldPrediction = predictYield(weatherHistory, currentWeather);

                std::cout << "Predicted Crop Yield for " << selectedCrop << ": " << yieldPrediction << " tons." << std::endl;
                break;
            }
            case 3: {
                // Pollution Impact Analysis
                simulatePollutionGraph(10, 20); // 10 crops, 20 edges
                vector<double> pollutionLevels(MAX_CROPS, 0);

                if (selectedCrop == "None")
                {
                    std::cout << "Please select a crop first (Option 1 in the menu)." << std::endl;
                    break;
                }

                int selectedIndex = -1;
                for (int i = 0; i < cropNames.size(); i++)
                {
                    if (cropNames[i] == selectedCrop)
                    {
                        selectedIndex = i;
                        break;
                    }
                }

                analyzePollutionImpact(selectedIndex, pollutionLevels);

                std::cout << "\nPollution Impact Analysis for " << selectedCrop << ":" << std::endl;

                for (const auto& neighbor : adj[selectedIndex])
                {
                    std::cout << "Pollution Level from " << selectedCrop << " to " << neighbor.first << ": "
                              << neighbor.second << std::endl;
                }

                std::cout << "Total Pollution Level affecting " << selectedCrop << ": " << pollutionLevels[selectedIndex] << std::endl;

                break;
            }
            case 4: {
                // Urban Beekeeping Logistics
                simulateLogisticsGraph(10, 20); // 10 crops, 20 edges

                if (selectedCrop == "None")
                {
                    std::cout << "Please select a crop first (Option 1 in the menu)." << std::endl;
                    break;
                }

                int selectedIndex = -1;
                for (int i = 0; i < cropNames.size(); i++)
                {
                    if (cropNames[i] == selectedCrop)
                    {
                        selectedIndex = i;
                        break;
                    }
                }

                vector<double> shortestPaths = dijkstra(selectedIndex, 10);

                std::cout << "\nLogistics Details Starting from " << selectedCrop << ":" << std::endl;

                for (int i = 0; i < 10; i++) {
                    std::cout << "Shortest path to " << cropNames[i] << ": " << shortestPaths[i] << " units of cost." << std::endl;
                }
                break;
            }
            case 5: {
                // Places Around the Farm
                vector<Place> places = {
                    {"Central Market", 15.0, 2.5},
                    {"Urban Distributor", 10.0, 3.0},
                    {"Regional Warehouse", 25.0, 1.8},
                    {"Export Hub", 40.0, 4.0}
                };

                std::cout << "\nPlaces around the farm and their details:" << std::endl;
                describePlaces(places);

                showYieldMenu();
                std::cin >> yieldAmount;

                double totalSupplyCost = calculateTotalSupplyCost(places, yieldAmount);
                std::cout << "\nTotal Harvest Supply Cost for " << yieldAmount << " tons of " << selectedCrop << ": " << totalSupplyCost << " units" << std::endl;

                suggestBestOption(places, yieldAmount);
                break;
            }
            case 6: {
                // Soil Improvement Suggestions
                displaySoilImprovementSuggestions();
                break;
            }
            case 7:
                std::cout << "Exiting the program. Goodbye!" << std::endl;
                break;
            default:
                std::cout << "Invalid choice. Please select a valid option." << std::endl;
        }
    } while (mainChoice != 7);

    std::cout << "Main program started." << std::endl;

    // Call the algorithm function
    vector<int> algorithm_data = {1, 2, 3, 4}; // Example algorithm input
    int algorithm_output = algorithm_function(algorithm_data);

    // Print the output of the algorithm function (optional)
    std::cout << "Output from algorithm_function: " << algorithm_output << std::endl;

    std::cout << "Main program finished." << std::endl;
}

// Function for the fourth main logic
class RenewableEnergy
{
private:
    double solarEnergyProduced;
    double windEnergyProduced;
    double energyUsed;
    double energyStored;
    double totalSolarEnergyProduced;
    double totalWindEnergyProduced;

public:
    RenewableEnergy() : solarEnergyProduced(0), windEnergyProduced(0), energyUsed(0), energyStored(0), totalSolarEnergyProduced(0), totalWindEnergyProduced(0) {}

    void produceSolarEnergy(double hours)
    {
        solarEnergyProduced = hours * 5.0;
        totalSolarEnergyProduced += solarEnergyProduced;
        cout << "Solar energy produced: " << solarEnergyProduced << " kWh\n";
    }

    void produceWindEnergy(double hours)
    {
        windEnergyProduced = hours * 2.0;
        totalWindEnergyProduced += windEnergyProduced;
        cout << "Wind energy produced: " << windEnergyProduced << " kWh\n";
    }

    void useEnergy(double energy)
    {
        energyUsed += energy;
        cout << "Energy used: " << energyUsed << " kWh\n";
    }

    void storeEnergy()
    {
        energyStored += (solarEnergyProduced + windEnergyProduced) - energyUsed;
        cout << "Energy stored: " << energyStored << " kWh\n";
    }

    double totalEnergyProduced()
    {
        return totalSolarEnergyProduced + totalWindEnergyProduced;
    }

    double calculateCarbonSavings()
    {
        return totalEnergyProduced() * 0.5;
    }

    void reportEnergyStatus()
    {
        cout << "Total energy produced (solar + wind): " << totalEnergyProduced() << " kWh\n";
        cout << "Total energy stored: " << energyStored << " kWh\n";
        cout << "Total energy used: " << energyUsed << " kWh\n";
    }

    void saveToFile()
    {
        ofstream energyFile("energy_management.txt", ios::app);
        energyFile << "Energy Report:\n";
        energyFile << "Solar energy produced: " << solarEnergyProduced << " kWh\n";
        energyFile << "Wind energy produced: " << windEnergyProduced << " kWh\n";
        energyFile << "Energy used: " << energyUsed << " kWh\n";
        energyFile << "Energy stored: " << energyStored << " kWh\n";
        energyFile.close();
    }
};
class PlantGrowth
{
private:
    double plantHeight;
    double plantHealth;
    double sunlightHours;
    double waterLevel;
    double soilNutrients;
    map<string, double> plantHealthModifiers;

public:
    PlantGrowth() : plantHeight(0), plantHealth(100), sunlightHours(0), waterLevel(0), soilNutrients(0)
    {

        plantHealthModifiers["sunlight"] = 0.4;
        plantHealthModifiers["water"] = 0.4;
        plantHealthModifiers["soil"] = 0.2;
    }

    void simulateGrowth()
    {
        plantHeight += (sunlightHours * 0.2) + (waterLevel * 0.3) + (soilNutrients * 0.1);
        plantHealth = (sunlightHours * plantHealthModifiers["sunlight"]) + (waterLevel * plantHealthModifiers["water"]) + (soilNutrients * plantHealthModifiers["soil"]);
        if (plantHealth < 50)
        {
            cout << "Warning: Plant health is low! Consider improving growing conditions.\n";
        }
        cout << "Current plant height: " << plantHeight << " cm\n";
        cout << "Current plant health: " << plantHealth << "%\n";
    }

    void updateSunlight(double hours)
    {
        sunlightHours = hours;
    }

    void updateWaterLevel(double level)
    {
        waterLevel = level;
    }

    void updateSoilNutrients(double nutrients)
    {
        soilNutrients = nutrients;
    }

    void adjustHealthModifiers(double sunlight, double water, double soil)
    {
        plantHealthModifiers["sunlight"] = sunlight;
        plantHealthModifiers["water"] = water;
        plantHealthModifiers["soil"] = soil;
    }

    void reportGrowthStatus()
    {
        cout << "Plant Height: " << plantHeight << " cm\n";
        cout << "Plant Health: " << plantHealth << "%\n";
    }

    void saveToFile()
    {
        ofstream plantFile("plant_growth.txt", ios::app);
        plantFile << "Plant Growth Report:\n";
        plantFile << "Plant Height: " << plantHeight << " cm\n";
        plantFile << "Plant Health: " << plantHealth << "%\n";
        plantFile.close();
    }
};
class WasteManagement3
{
private:
    double organicWasteCollected;
    double compostProduced;
    double biogasProduced;
    double totalCompostProduced;
    double totalBiogasProduced;

public:
    WasteManagement3() : organicWasteCollected(0), compostProduced(0), biogasProduced(0), totalCompostProduced(0), totalBiogasProduced(0) {}

    void collectWaste(double weight)
    {
        organicWasteCollected += weight;
        cout << "Organic waste collected: " << organicWasteCollected << " kg\n";
    }

    void compostWaste()
    {
        compostProduced = organicWasteCollected * 0.5;
        totalCompostProduced += compostProduced;
        cout << "Compost produced: " << compostProduced << " kg\n";
    }

    void produceBiogas()
    {
        biogasProduced = organicWasteCollected * 0.6;
        totalBiogasProduced += biogasProduced;
        cout << "Biogas produced: " << biogasProduced << " m\n";
    }

    void reportEnvironmentalImpact()
    {
        cout << "Total compost produced: " << totalCompostProduced << " kg\n";
        cout << "Total biogas produced: " << totalBiogasProduced << " m\n";
    }

    void saveToFile()
    {
        ofstream wasteFile("waste_management.txt", ios::app);
        wasteFile << "Waste Report:\n";
        wasteFile << "Organic waste collected: " << organicWasteCollected << " kg\n";
        wasteFile << "Compost produced: " << compostProduced << " kg\n";
        wasteFile << "Biogas produced: " << biogasProduced << " m\n";
        wasteFile.close();
    }
};
class UrbanFarm
{
private:
    RenewableEnergy energySystem;
    WasteManagement3 wasteSystem;
    PlantGrowth plantSystem;
    double totalCarbonSavings;
    queue<string> tasksQueue;

public:
    UrbanFarm() : totalCarbonSavings(0) {}

    void dailyOperations(double solarHours, double windHours, double energyUsed, double wasteCollected,
                         double sunlightHours, double waterLevel, double soilNutrients)
    {
        energySystem.produceSolarEnergy(solarHours);
        energySystem.produceWindEnergy(windHours);
        energySystem.useEnergy(energyUsed);
        energySystem.storeEnergy();

        wasteSystem.collectWaste(wasteCollected);
        wasteSystem.compostWaste();
        wasteSystem.produceBiogas();

        totalCarbonSavings += energySystem.calculateCarbonSavings();

        plantSystem.updateSunlight(sunlightHours);
        plantSystem.updateWaterLevel(waterLevel);
        plantSystem.updateSoilNutrients(soilNutrients);
        plantSystem.simulateGrowth();
    }

    void reportFarmStatus()
    {
        cout << "Total Carbon Savings from Renewable Energy: " << totalCarbonSavings << " kg of CO2\n";
        wasteSystem.reportEnvironmentalImpact();
        energySystem.reportEnergyStatus();
        plantSystem.reportGrowthStatus();
    }

    void addTask(string task)
    {
        tasksQueue.push(task);
    }

    void processTasks()
    {
        while (!tasksQueue.empty())
        {
            string task = tasksQueue.front();
            cout << "Processing task: " << task << endl;
            tasksQueue.pop();
        }
    }

    void saveToFile()
    {
        ofstream farmFile("urban_farm.txt", ios::app);
        farmFile << "Urban Farm Report:\n";
        farmFile << "Total Carbon Savings: " << totalCarbonSavings << " kg\n";
        farmFile.close();
    }
};

// Class definition for PollutionMonitor
class PollutionMonitor
{
private:
    double airPollutionLevel;
    double waterPollutionLevel;

public:
    PollutionMonitor() : airPollutionLevel(0), waterPollutionLevel(0) {}

    void trackPollution(double airPollution, double waterPollution)
    {
        airPollutionLevel = airPollution;
        waterPollutionLevel = waterPollution;
        cout << "Air Pollution: " << airPollutionLevel << " AQI\n";
        cout << "Water Pollution: " << waterPollutionLevel << " ppm\n";
    }

    void reportPollutionStatus()
    {
        if (airPollutionLevel > 150)
        {
            cout << "Air pollution is high! Immediate action required.\n";
        }
        else
        {
            cout << "Air pollution levels are safe.\n";
        }

        if (waterPollutionLevel > 50)
        {
            cout << "Water pollution is high! Immediate action required.\n";
        }
        else
        {
            cout << "Water pollution levels are safe.\n";
        }
    }

    void saveToFile()
    {
        ofstream pollutionFile("pollution_report.txt", ios::app);
        pollutionFile << "Pollution Report:\n";
        pollutionFile << "Air Pollution Level: " << airPollutionLevel << " AQI\n";
        pollutionFile << "Water Pollution Level: " << waterPollutionLevel << " ppm\n";
        pollutionFile.close();
    }
};
#include <fstream>
// Class definition for ResourceConsumption
class ResourceConsumption
{
private:
    double waterUsed;
    double energyConsumed;

public:
    ResourceConsumption() : waterUsed(0), energyConsumed(0) {}

    void trackWaterUsage(double water)
    {
        waterUsed += water;
        cout << "Water used: " << waterUsed << " liters\n";
    }

    void trackEnergyUsage(double energy)
    {
        energyConsumed += energy;
        cout << "Energy consumed: " << energyConsumed << " kWh\n";
    }

    void reportResourceStatus()
    {
        cout << "Total water used: " << waterUsed << " liters\n";
        cout << "Total energy consumed: " << energyConsumed << " kWh\n";
    }

    void saveToFile()
    {
        ofstream resourceFile("resource_consumption.txt", ios::app);
        resourceFile << "Resource Consumption Report:\n";
        resourceFile << "Water used: " << waterUsed << " liters\n";
        resourceFile << "Energy consumed: " << energyConsumed << " kWh\n";
        resourceFile.close();
    }
};
// Function to display the menu
void displayMenu() {
    cout << "1. Check Air Quality" << endl;
    cout << "2. Check Water Quality" << endl;
    cout << "3. Report Resource Status" << endl;
    cout << "4. Report Pollution Status" << endl;
    cout << "5. Report Farm Status" << endl;
    cout << "6. Add Task" << endl;
    cout << "7. Process Tasks" << endl;
    cout << "8. Exit" << endl;
    cout << "Enter your choice: ";
}

// Function to get a valid integer input from the user
/*

// Function to check air quality
void checkAirQuality() {
    //cout << "Checking air quality..." << endl;

}*/
/*
// Function to check water quality
void checkWaterQuality() {
    cout << "Checking water quality..." << endl;
}
*/
// Main function for option 4
void mainOption4() {
    UrbanFarm farm;
    PollutionMonitor pollutionMonitor;
    ResourceConsumption resourceConsumption;

    farm.dailyOperations(5.0, 3.0, 20.0, 50.0, 8.0, 100.0, 50.0);
    farm.dailyOperations(6.0, 4.0, 18.0, 40.0, 10.0, 120.0, 60.0);

    farm.reportFarmStatus();

    pollutionMonitor.trackPollution(120, 45);
    resourceConsumption.trackWaterUsage(150);
    resourceConsumption.trackEnergyUsage(30);

    int choice;
    while (true) {
        displayMenu();
        choice = getValidInteger();

        switch (choice) {
            case 1:
                checkAirQuality();
                break;
            case 2:
                checkWaterQuality();
                break;
            case 3:
                resourceConsumption.reportResourceStatus();
                break;
            case 4:
                pollutionMonitor.reportPollutionStatus();
                break;
            case 5:
                farm.reportFarmStatus();
                break;
            case 6: {
                std::cout << "Enter task description: ";
                std::string task;
                std::cin.ignore();
                std::getline(std::cin, task);
                farm.addTask(task);
                break;
            }
            case 7:
                farm.processTasks();
                break;
            case 8:
                std::cout << "Exiting the system. Goodbye!\n";
                return;
            default:
                std::cout << "Invalid choice! Please select a valid option.\n";
        }
    }
}

// Function to display the menu for option 1
void showMenu1() {
    cout << "\nUrban Agriculture Management System\n";
    cout << "1. Optimize Crop Arrangement\n";
    cout << "2. Determine Allocation Times\n";
    cout << "3. Analyze Soil Samples\n";
    cout << "4. Suggest Crop Rotation Plan\n";
    cout << "5. Estimate Crop Yields\n";
    cout << "6. Manage Farming Tools\n";
    cout << "7. Manage Crop Nutrients\n";
    cout << "8. Manage Resource Sharing\n";
    cout << "9. Manage Farm Graph\n";
    cout << "10. Manage Water Supply Network\n";
    cout << "11. Manage Resource Network\n";
    cout << "12. Manage Irrigation System\n";
    cout << "13. Manage Crop Dependencies\n";
    cout << "14. Manage Harvest Schedule\n";
    cout << "15. Manage Crop Profit Maximization\n";
    cout << "16. Manage Optimal Land Partitioning\n";
    cout << "17. Manage Nutrient Allocation\n";
    cout << "18. Monitor Soil Moisture\n";
    cout << "19. Calculate Water Usage\n";
    cout << "20. Calculate Crop Rotation Benefits\n";
    cout << "21. Analyze Soil Erosion Risk\n";
    cout << "22. Solve Nutrient Subset Problem\n";
    cout << "23. Evaluate Undecidable Plans\n";
    cout << "24. Monitor Real-Time Environmental Data\n";
    cout << "25. Manage Pest Control\n";
    cout << "0. Exit\n";
    cout << "Enter your choice: ";
}

// Main function for option 1
void mainOption1(){
    int choice;
    do {
        showMenu1();
        cin >> choice;
        switch (choice) {
            case 1:
                cout << "\nOptimize Crop Arrangement\n";
                cout << "This function helps you arrange your crops in an optimal way to maximize yield.\n";
                 optimizeCropArrangement(); // Placeholder for function call
                break;
            case 2:
                cout << "\nDetermine Allocation Times\n";
                cout << "This function calculates the total allocation times for various resources.\n";
                 determineAllocationTimes(); // Placeholder for function call
                break;
            case 3:
                cout << "\nAnalyze Soil Samples\n";
                cout << "This function analyzes soil samples to determine nutrient levels and pH.\n";
                 analyzeSoilSamples(); // Placeholder for function call
                break;
            case 4:
                cout << "\nSuggest Crop Rotation Plan\n";
                cout << "This function suggests a crop rotation plan to maintain soil health and reduce pests.\n";
                 suggestCropRotation(); // Placeholder for function call
                break;
            case 5:
                cout << "\nEstimate Crop Yields\n";
                cout << "This function estimates the yields of different crops based on conditions.\n";
                 estimateCropYields(); // Placeholder for function call
                break;
            case 6:
                cout << "\nManage Farming Tools\n";
                cout << "This function helps manage the power and operational hours of farming tools.\n";
                 manageFarmingTools(); // Placeholder for function call
                break;
            case 7:
                cout << "\nManage Crop Nutrients\n";
                cout << "This function manages the nutrient requirements and allocations for crops.\n";
                 manageCropNutrients(); // Placeholder for function call
                break;
            case 8:
                cout << "\nManage Resource Sharing\n";
                cout << "This function facilitates sharing resources between farms.\n";
                 manageResourceSharing(); // Placeholder for function call
                break;
            case 9:
                cout << "\nManage Farm Graph\n";
                cout << "This function manages the dependencies and resources between farms.\n";
                 manageFarmGraph(); // Placeholder for function call
                break;
            case 10:
                cout << "\nManage Water Supply Network\n";
                cout << "This function optimizes the water supply network for efficient distribution.\n";
                 manageWaterSupplyGraph(); // Placeholder for function call
                break;
            case 11:
                cout << "\nManage Resource Network\n";
                cout << "This function manages the minimum spanning tree for resource distribution.\n";
                 manageResourceNetwork(); // Placeholder for function call
                break;
            case 12:
                cout << "\nManage Irrigation System\n";
                cout << "This function optimizes the irrigation system for maximum efficiency.\n";
                 manageIrrigationSystem(); // Placeholder for function call
                break;
            case 13:
                cout << "\nManage Crop Dependencies\n";
                cout << "This function manages the dependencies between different crops.\n";
                 manageCropDependencies(); // Placeholder for function call
                break;
            case 14:
                cout << "\nManage Harvest Schedule\n";
                cout << "This function helps in planning the harvest schedule to maximize profit.\n";
                manageHarvestSchedule(); // Placeholder for function call
                break;
            case 15:
                cout << "\nManage Crop Profit Maximization\n";
                cout << "This function helps in maximizing the profit from different crops.\n";
                manageCropProfitMaximization(); // Placeholder for function call
                break;
            case 16:
                cout << "\nManage Optimal Land Partitioning\n";
                cout << "This function helps in partitioning the land optimally for different crops.\n";
                 manageOptimalLandPartitioning(); // Placeholder for function call
                break;
            case 17:
                cout << "\nManage Nutrient Allocation\n";
                cout << "This function allocates nutrients dynamically based on real-time data.\n";
                 manageNutrientAllocation(); // Placeholder for function call
                break;
            case 18: {
                cout << "\nMonitor Soil Moisture\n";
                cout << "This function monitors soil moisture levels and provides irrigation recommendations.\n";
                int numSamples;
                cout << "Enter the number of soil samples: ";
                cin >> numSamples;
                vector<SoilMoisture> samples(numSamples);
                for (int i = 0; i < numSamples; ++i) {
                    cout << "Enter Sample ID and Moisture Level (%): ";
                    cin >> samples[i].sampleID >> samples[i].moistureLevel;
                }
                 monitorSoilMoisture(samples); // Placeholder for function call
                break;
            }
            case 19: {
                cout << "\nCalculate Water Usage\n";
                cout << "This function calculates the total water usage based on crop requirements.\n";
                int numCrops;
                cout << "Enter the number of crops: ";
                cin >> numCrops;
                vector<WaterUsage> crops(numCrops);
                for (int i = 0; i < numCrops; ++i) {
                    cout << "Enter Crop Name, Water Required per Hectare (liters), and Area planted (hectares): ";
                    cin >> crops[i].cropName >> crops[i].waterPerHectare >> crops[i].area;
                }
                 calculateWaterUsage(crops); // Placeholder for function call
                break;
            }
            case 20: {
                cout << "\nCalculate Crop Rotation Benefits\n";
                cout << "This function calculates the benefits of rotating different crops.\n";
                int numCrops;
                cout << "Enter the number of crops: ";
                cin >> numCrops;
                vector<CropRotationBenefit> crops(numCrops);
                for (int i = 0; i < numCrops; ++i) {
                    cout << "Enter Crop Name, Nutrient Replenishment Value, and Pest Control Value: ";
                    cin >> crops[i].cropName >> crops[i].nutrientReplenishment >> crops[i].pestControl;
                }
                calculateCropRotationBenefits(crops); // Placeholder for function call
                break;
            }
            case 21: {
                cout << "\nAnalyze Soil Erosion Risk\n";
                cout << "This function analyzes soil erosion risk based on slope and rainfall.\n";
                int numSamples;
                cout << "Enter the number of soil samples: ";
                cin >> numSamples;
                vector<SoilErosionRisk> samples(numSamples);
                for (int i = 0; i < numSamples; ++i) {
                    cout << "Enter Soil Type, Slope (%), and Rainfall (mm): ";
                    cin >> samples[i].soilType >> samples[i].slope >> samples[i].rainfall;
                }
                 analyzeSoilErosionRisk(samples); // Placeholder for function call
                break;
            }
            case 22:
                cout << "\nSolve Nutrient Subset Problem\n";
                cout << "This function checks if a subset of nutrients can meet a required nutrient value.\n";
                gatherAndSolveNutrientSubsetProblem(); // Placeholder for function call
                break;
            case 23:
                cout << "\nEvaluate Undecidable Plans\n";
                cout << "This function evaluates plans to determine if resource demands can be met.\n";
                 gatherAndEvaluateUndecidablePlans(); // Placeholder for function call
                break;
            case 24: {
                cout << "\nMonitor Real-Time Environmental Data\n";
                cout << "This function monitors environmental data such as temperature, humidity, and light levels.\n";
                int numData;
                cout << "Enter the number of data points: ";
                cin >> numData;
                vector<EnvironmentalData> data(numData);
                for (int i = 0; i < numData; ++i) {
                    cout << "Enter Temperature (C), Humidity (%), and Light Level (lux): ";
                    cin >> data[i].temperature >> data[i].humidity >> data[i].lightLevel;
                }
                 monitorEnvironmentalData(data); // Placeholder for function call
                break;
            }
            case 25: {
                cout << "\nManage Pest Control\n";
                cout << "This function manages pest control based on pest type and severity level.\n";
                int numData;
                cout << "Enter the number of pest data points: ";
                cin >> numData;
                vector<PestData> data(numData);
                for (int i = 0; i < numData; ++i) {
                    cout << "Enter Pest Type and Severity Level (1-10): ";
                    cin >> data[i].pestType >> data[i].severityLevel;
                }
                managePestControl(data); // Placeholder for function call
                break;
            }
            case 0:
                cout << "Exiting program.\n";
                break;
            default:
                cout << "Invalid choice. Please try again.\n";
        }
    } while (choice != 0);
}

// Main function with switch case to choose between the other main functions
int main() {
    int option;
    std::cout << "Select an option:\n";
    std::cout << "1. Advanced Farming Optimization System\n";
    std::cout << "2. Farm Management System\n";
    std::cout << "3. Yield Prediction and Pollution Analysis\n";
    std::cout << "4. Urban Farming Environmental Monitoring System\n";
    std::cout << "Enter your choice: ";
    std::cin >> option;

    switch (option) {
        case 1:
            mainOption1();
            break;
        case 2:
            mainOption2();
            break;
        case 3:
            mainOption3();
            break;
        case 4:
            mainOption4();
            break;
        default:
            std::cout << "Invalid option! Exiting...\n";
            break;
    }

    return 0;
}
